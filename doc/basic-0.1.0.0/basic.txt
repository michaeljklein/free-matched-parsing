-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/basic#readme</a>
@package basic
@version 0.1.0.0

module Control.FoldF
newtype FoldF f a b
FoldF :: Either (f b) (Fold a (f b)) -> FoldF f a b
[runFoldF] :: FoldF f a b -> Either (f b) (Fold a (f b))
liftFoldF :: f b -> FoldF f a b
apFoldF :: (f a -> g b -> h c) -> FoldF f t a -> FoldF g t b -> FoldF h t c
hoistFoldF :: Functor f => (forall t. f t -> g t) -> FoldF f a b -> FoldF g a b
mapFoldF :: (f b -> g d) -> (Fold a (f b) -> Fold c (g d)) -> FoldF f a b -> FoldF g c d

-- | Apply a <a>FoldF</a> to a <a>Foldable</a> input
foldF :: Foldable t => FoldF f a b -> t a -> f b
instance GHC.Base.Functor f => GHC.Base.Functor (Control.FoldF.FoldF f a)
instance GHC.Base.Functor f => Data.Profunctor.Unsafe.Profunctor (Control.FoldF.FoldF f)
instance (GHC.Base.Functor f, Data.Pointed.Pointed f) => Data.Profunctor.Choice.Choice (Control.FoldF.FoldF f)
instance Control.Comonad.Comonad f => Control.Comonad.Comonad (Control.FoldF.FoldF f a)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Control.FoldF.FoldF f a)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.FoldF.FoldF f a)

module Data.Buffered
newtype CofreeF f a
CofreeF :: f (Cofree f a) -> CofreeF f a
[runCofreeF] :: CofreeF f a -> f (Cofree f a)
data Fd

-- | <a>undefined</a>
--   
--   <pre>
--   allocaBytes :: Int -&gt; (Ptr a -&gt; IO b) -&gt; IO b
--   </pre>
allocaBytes :: Int -> (Ptr Word8 -> IO b) -> IO b

-- | <a>undefined</a>
unsafePackCStringFinalizer :: Ptr Word8 -> Int -> IO () -> IO ByteString

-- | Use <a>unsafePackCStringFinalizer</a> to wrap the result of
--   <a>allocaBytes</a>
allocaByteString :: Int -> (ByteString -> IO a) -> IO a
data BufferState m
BufferState :: !ByteString -> !(Ptr Word8) -> m ByteString -> BufferState m
[buffer] :: BufferState m -> !ByteString
[bufferPtr] :: BufferState m -> !(Ptr Word8)
[fillBuffer] :: BufferState m -> m ByteString

-- | <a>undefined</a>
initialBufferState :: MonadIO m => Int -> Fd -> m (BufferState m)

-- | <a>undefined</a>
refillBuffer :: StateT (BufferState m) m ()

-- | <a>undefined</a>
buildBuffered :: StateT ByteString m a -> Int -> Fd -> CofreeF (StateT (BufferState m) m) Char

-- | <a>undefined</a>
decode :: ByteString -> Maybe (Char, Int)

module Data.Matched

-- | Dummy type for non-empty ranges
data Range1 a

-- | We wncode the following GADT using <a>F</a> and <a>EnvT</a>:
--   
--   <pre>
--   data Matched s f a where
--     NonMatched :: a -&gt; Matched s f a
--     Matched :: s -&gt; f (Matched s f a) -&gt; Matched s f a
--   </pre>
newtype MatchedT s f a
MatchedT :: F (EnvT s f) a -> MatchedT s f a
[runMatchedT] :: MatchedT s f a -> F (EnvT s f) a
mapEnvT :: (s -> t) -> EnvT s f a -> EnvT t f a
hoistEnvT :: (forall t. f t -> g t) -> EnvT s f a -> EnvT s g a
withMatchedT :: (F (EnvT s f) a -> F (EnvT t g) b) -> MatchedT s f a -> MatchedT t g b
mapMatchedT :: (s -> t) -> MatchedT s f a -> MatchedT t f a
hoistMatchedT :: Functor f => (forall t. f t -> g t) -> MatchedT s f a -> MatchedT s g a
wrapMatchedT :: Functor f => EnvT s f (MatchedT s f a) -> MatchedT s f a
newtype Matched (s :: [*]) f a
Matched :: MatchedT (NS I s) f a -> Matched f a
[runMatched] :: Matched f a -> MatchedT (NS I s) f a
class Traversable s => Stack s
pop :: Stack s => s a -> Maybe a
push :: Stack s => s a -> a -> s a
newtype FoldRemainder w m
FoldRemainder :: (forall b. FoldM m (w Char) b -> m b) -> FoldRemainder w m
[runFoldRemainder] :: FoldRemainder w m -> forall b. FoldM m (w Char) b -> m b
newtype ParserT w m a
Parser :: FoldM (ExceptT (a, FoldRemainder w m) m) (w Char) a -> ParserT w m a
[runParser] :: ParserT w m a -> FoldM (ExceptT (a, FoldRemainder w m) m) (w Char) a

-- | Those sum elements that we can <tt>reify</tt> to <a>Match</a>
type HasMatch s = Reifies s Match
data Match
Match :: !Char -> !Char -> Match
[matchOpen] :: Match -> !Char
[matchClose] :: Match -> !Char

-- | Location
newtype Loc
Loc :: Word16 -> Loc
[getLoc] :: Loc -> Word16

-- | Location range
newtype LocR
LocR :: Range1 Loc -> LocR
[getLocR] :: LocR -> Range1 Loc
class MonoidN s
memptyN :: MonoidN s => s 0
mappendN :: MonoidN s => s n -> s m -> s (n + m)
class MonoidN s => StackN s e
pushN :: StackN s e => e -> s n -> s (n + 1)
popN :: StackN s e => s (n + 1) -> (e, s n)

-- | <a>Nat</a>-indexed strict stack of <a>Int</a>s
data IntStack (n :: Nat)
[EmptyIntStack] :: IntStack 0
[PushIntStack] :: !Int -> !(IntStack n) -> IntStack (n + 1)
newtype UnmatchedT s (unmatched :: Nat) m a
UnmatchedT :: m (a, s unmatched) -> UnmatchedT s m a
[runUnmatchedT] :: UnmatchedT s m a -> m (a, s unmatched)
matchWith :: (Monad m, StackN s e) => (e -> i -> m ()) -> i -> UnmatchedT s (1 + unmatched) m a -> UnmatchedT s unmatched m a
newtype LineT v (lineNo :: Nat) m a
LineT :: m (v (PrimState m) (Env LocR a)) -> LineT v m a
[runLineT] :: LineT v m a -> m (v (PrimState m) (Env LocR a))
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Matched.UnmatchedT s unmatched m)
instance GHC.Read.Read Data.Matched.Match
instance GHC.Show.Show Data.Matched.Match
instance GHC.Classes.Ord Data.Matched.Match
instance GHC.Classes.Eq Data.Matched.Match
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Matched.Matched s f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Matched.Matched s f)
instance Control.Monad.Fix.MonadFix (Data.Matched.Matched s f)
instance GHC.Base.Monad (Data.Matched.Matched s f)
instance GHC.Base.Applicative (Data.Matched.Matched s f)
instance GHC.Base.Functor (Data.Matched.Matched s f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Data.Matched.MatchedT s f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Data.Matched.MatchedT s f)
instance Control.Monad.Fix.MonadFix (Data.Matched.MatchedT s f)
instance GHC.Base.Monad (Data.Matched.MatchedT s f)
instance GHC.Base.Applicative (Data.Matched.MatchedT s f)
instance GHC.Base.Functor (Data.Matched.MatchedT s f)
instance Data.Matched.MonoidN Data.Matched.IntStack
instance Data.Matched.StackN Data.Matched.IntStack GHC.Types.Int
instance Data.String.IsString Data.Matched.Match

module Data.Matched.Cofree

-- | Input is finite foldable and what to do with the gaps between matched.
--   Output is matched
data MatchType
None :: MatchType
Parens :: MatchType
Bracket :: MatchType
Brace :: MatchType

-- | Matches on inputs of type <tt>a</tt> with shape <tt>f</tt> and results
--   of type <tt>b</tt>
--   
--   <pre>
--   data Matched f a where
--     Matched :: !MatchType -&gt; f (Matched f a) -&gt; Matched f a
--     UnMatched :: !MatchType -&gt; Fold (Matched f a) (f (Matched f a)) -&gt; Matched f a
--   </pre>
newtype Matched a f b
Matched :: CofreeT (FoldF f a) (Env MatchType) b -> Matched a f b
[runMatched] :: Matched a f b -> CofreeT (FoldF f a) (Env MatchType) b
preMatched :: Functor f => (a -> b) -> Matched b f c -> Matched a f c
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Matched.Cofree.Matched a f)
instance GHC.Enum.Enum Data.Matched.Cofree.MatchType
instance GHC.Read.Read Data.Matched.Cofree.MatchType
instance GHC.Show.Show Data.Matched.Cofree.MatchType
instance GHC.Classes.Ord Data.Matched.Cofree.MatchType
instance GHC.Classes.Eq Data.Matched.Cofree.MatchType
instance GHC.Base.Functor f => Control.Comonad.Comonad (Data.Matched.Cofree.Matched a f)
instance GHC.Base.Functor f => Control.Comonad.Env.Class.ComonadEnv Data.Matched.Cofree.MatchType (Data.Matched.Cofree.Matched a f)
instance GHC.Base.Functor f => Control.Comonad.Cofree.Class.ComonadCofree (Control.FoldF.FoldF f a) (Data.Matched.Cofree.Matched a f)
