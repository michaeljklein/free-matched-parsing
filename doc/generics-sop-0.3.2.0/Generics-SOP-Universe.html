<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Generics.SOP.Universe</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Generics.SOP.Universe.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">generics-sop-0.3.2.0: Generic Programming using True Sums of Products</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Generics.SOP.Universe</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Codes and interpretations</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Rep">Rep</a> a = <a href="Generics-SOP-NS.html#t:SOP">SOP</a> <a href="Generics-SOP-BasicFunctors.html#t:I">I</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a)</li><li class="src short"><span class="keyword">class</span> <a href="Generics-SOP-Constraint.html#t:All">All</a> <a href="Generics-SOP-Sing.html#t:SListI">SListI</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a) =&gt; <a href="#t:Generic">Generic</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:Code">Code</a> a :: [[<a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>]]</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:HasDatatypeInfo">HasDatatypeInfo</a> a <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:DatatypeInfoOf">DatatypeInfoOf</a> a :: <a href="Generics-SOP-Type-Metadata.html#t:DatatypeInfo">DatatypeInfo</a></li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:IsProductType">IsProductType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (xs :: [<a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>]) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Code">Code</a> a ~ '[xs])</li><li class="src short"><span class="keyword">type</span> <a href="#t:IsEnumType">IsEnumType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Constraint.html#t:All">All</a> ((~) '[]) (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a))</li><li class="src short"><span class="keyword">type</span> <a href="#t:IsWrappedType">IsWrappedType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (x :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Code">Code</a> a ~ '['[x]])</li><li class="src short"><span class="keyword">type</span> <a href="#t:IsNewtype">IsNewtype</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (x :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:IsWrappedType">IsWrappedType</a> a x, <a href="../base-4.10.1.0/Data-Coerce.html#t:Coercible">Coercible</a> a x)</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Rep" class="def">Rep</a> a = <a href="Generics-SOP-NS.html#t:SOP">SOP</a> <a href="Generics-SOP-BasicFunctors.html#t:I">I</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a) <a href="src/Generics.SOP.Universe.html#Rep" class="link">Source</a> <a href="#t:Rep" class="selflink">#</a></p><div class="doc"><p>The (generic) representation of a datatype.</p><p>A datatype is isomorphic to the sum-of-products of its code.
 The isomorphism is witnessed by <code><a href="Generics-SOP-Universe.html#v:from">from</a></code> and <code><a href="Generics-SOP-Universe.html#v:to">to</a></code> from the
 <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code> class.</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Generics-SOP-Constraint.html#t:All">All</a> <a href="Generics-SOP-Sing.html#t:SListI">SListI</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a) =&gt; <a id="t:Generic" class="def">Generic</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) <span class="keyword">where</span> <a href="src/Generics.SOP.Universe.html#Generic" class="link">Source</a> <a href="#t:Generic" class="selflink">#</a></p><div class="doc"><p>The class of representable datatypes.</p><p>The SOP approach to generic programming is based on viewing
 datatypes as a representation (<code><a href="Generics-SOP-Universe.html#t:Rep">Rep</a></code>) built from the sum of
 products of its components. The components of are datatype
 are specified using the <code><a href="Generics-SOP-Universe.html#t:Code">Code</a></code> type family.</p><p>The isomorphism between the original Haskell datatype and its
 representation is witnessed by the methods of this class,
 <code><a href="Generics-SOP-Universe.html#v:from">from</a></code> and <code><a href="Generics-SOP-Universe.html#v:to">to</a></code>. So for instances of this class, the following
 laws should (in general) hold:</p><pre><code><a href="Generics-SOP-Universe.html#v:to">to</a></code> <code><a href="../base-4.10.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Generics-SOP-Universe.html#v:from">from</a></code> === <code><a href="../base-4.10.1.0/Data-Function.html#v:id">id</a></code> :: a -&gt; a
<code><a href="Generics-SOP-Universe.html#v:from">from</a></code> <code><a href="../base-4.10.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Generics-SOP-Universe.html#v:to">to</a></code> === <code><a href="../base-4.10.1.0/Data-Function.html#v:id">id</a></code> :: <code><a href="Generics-SOP-Universe.html#t:Rep">Rep</a></code> a -&gt; <code><a href="Generics-SOP-Universe.html#t:Rep">Rep</a></code> a
</pre><p>You typically don't define instances of this class by hand, but
 rather derive the class instance automatically.</p><p><em>Option 1:</em> Derive via the built-in GHC-generics. For this, you
 need to use the <code>DeriveGeneric</code> extension to first derive an
 instance of the <code><a href="../base-4.10.1.0/GHC-Generics.html#v:Generic">Generic</a></code> class from module <a href="../base-4.10.1.0/GHC-Generics.html">GHC.Generics</a>.
 With this, you can then give an empty instance for <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code>, and
 the default definitions will just work. The pattern looks as
 follows:</p><pre>import qualified <a href="../base-4.10.1.0/GHC-Generics.html">GHC.Generics</a> as GHC
import <a href="Generics-SOP.html">Generics.SOP</a>

...

data T = ... deriving (GHC.<code><a href="../base-4.10.1.0/GHC-Generics.html#v:Generic">Generic</a></code>, ...)

instance <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code> T -- empty
instance <code><a href="Generics-SOP-Universe.html#t:HasDatatypeInfo">HasDatatypeInfo</a></code> T -- empty, if you want/need metadata
</pre><p><em>Option 2:</em> Derive via Template Haskell. For this, you need to
 enable the <code>TemplateHaskell</code> extension. You can then use
 <code><a href="Generics-SOP-TH.html#v:deriveGeneric">deriveGeneric</a></code> from module <a href="Generics-SOP-TH.html">Generics.SOP.TH</a>
 to have the instance generated for you. The pattern looks as
 follows:</p><pre>import <a href="Generics-SOP.html">Generics.SOP</a>
import <a href="Generics-SOP-TH.html">Generics.SOP.TH</a>

...

data T = ...

<code><a href="Generics-SOP-TH.html#v:deriveGeneric">deriveGeneric</a></code> ''T -- derives <code><a href="Generics-SOP-Universe.html#t:HasDatatypeInfo">HasDatatypeInfo</a></code> as well
</pre><p><em>Tradeoffs:</em> Whether to use Option 1 or 2 is mainly a matter
 of personal taste. The version based on Template Haskell probably
 has less run-time overhead.</p><p><em>Non-standard instances:</em>
 It is possible to give <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code> instances manually that deviate
 from the standard scheme, as long as at least</p><pre><code><a href="Generics-SOP-Universe.html#v:to">to</a></code> <code><a href="../base-4.10.1.0/Data-Function.html#v:.">.</a></code> <code><a href="Generics-SOP-Universe.html#v:from">from</a></code> === <code><a href="../base-4.10.1.0/Data-Function.html#v:id">id</a></code> :: a -&gt; a
</pre><p>still holds.</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:Code" class="def">Code</a> a :: [[<a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>]] <a href="src/Generics.SOP.Universe.html#Code" class="link">Source</a> <a href="#t:Code" class="selflink">#</a></p><div class="doc"><p>The code of a datatype.</p><p>This is a list of lists of its components. The outer list contains
 one element per constructor. The inner list contains one element
 per constructor argument (field).</p><p><em>Example:</em> The datatype</p><pre>data Tree = Leaf Int | Node Tree Tree</pre><p>is supposed to have the following code:</p><pre>type instance Code (Tree a) =
  '[ '[ Int ]
   , '[ Tree, Tree ]
   ]</pre></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:from" class="def">from</a> :: a -&gt; <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a <a href="src/Generics.SOP.Universe.html#from" class="link">Source</a> <a href="#v:from" class="selflink">#</a></p><div class="doc"><p>Converts from a value to its structural representation.</p></div><p class="src"><a id="v:from" class="def">from</a> :: (<a href="Generics-SOP-GGP.html#t:GFrom">GFrom</a> a, <a href="../base-4.10.1.0/GHC-Generics.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a ~ <a href="Generics-SOP-NS.html#t:SOP">SOP</a> <a href="Generics-SOP-BasicFunctors.html#t:I">I</a> (<a href="Generics-SOP-GGP.html#t:GCode">GCode</a> a)) =&gt; a -&gt; <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a <a href="src/Generics.SOP.Universe.html#from" class="link">Source</a> <a href="#v:from" class="selflink">#</a></p><div class="doc"><p>Converts from a value to its structural representation.</p></div><p class="src"><a id="v:to" class="def">to</a> :: <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a -&gt; a <a href="src/Generics.SOP.Universe.html#to" class="link">Source</a> <a href="#v:to" class="selflink">#</a></p><div class="doc"><p>Converts from a structural representation back to the
 original value.</p></div><p class="src"><a id="v:to" class="def">to</a> :: (<a href="Generics-SOP-GGP.html#t:GTo">GTo</a> a, <a href="../base-4.10.1.0/GHC-Generics.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a ~ <a href="Generics-SOP-NS.html#t:SOP">SOP</a> <a href="Generics-SOP-BasicFunctors.html#t:I">I</a> (<a href="Generics-SOP-GGP.html#t:GCode">GCode</a> a)) =&gt; <a href="Generics-SOP-Universe.html#t:Rep">Rep</a> a -&gt; a <a href="src/Generics.SOP.Universe.html#to" class="link">Source</a> <a href="#v:to" class="selflink">#</a></p><div class="doc"><p>Converts from a structural representation back to the
 original value.</p></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a id="t:HasDatatypeInfo" class="def">HasDatatypeInfo</a> a <span class="keyword">where</span> <a href="src/Generics.SOP.Universe.html#HasDatatypeInfo" class="link">Source</a> <a href="#t:HasDatatypeInfo" class="selflink">#</a></p><div class="doc"><p>A class of datatypes that have associated metadata.</p><p>It is possible to use the sum-of-products approach to generic programming
 without metadata. If you need metadata in a function, an additional
 constraint on this class is in order.</p><p>You typically don't define instances of this class by hand, but
 rather derive the class instance automatically. See the documentation
 of <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code> for the options.</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:DatatypeInfoOf" class="def">DatatypeInfoOf</a> a :: <a href="Generics-SOP-Type-Metadata.html#t:DatatypeInfo">DatatypeInfo</a> <a href="src/Generics.SOP.Universe.html#DatatypeInfoOf" class="link">Source</a> <a href="#t:DatatypeInfoOf" class="selflink">#</a></p><div class="doc"><p>Type-level datatype info</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:datatypeInfo" class="def">datatypeInfo</a> :: proxy a -&gt; <a href="Generics-SOP-Metadata.html#t:DatatypeInfo">DatatypeInfo</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a) <a href="src/Generics.SOP.Universe.html#datatypeInfo" class="link">Source</a> <a href="#v:datatypeInfo" class="selflink">#</a></p><div class="doc"><p>Term-level datatype info; by default, the term-level datatype info is produced
 from the type-level info.</p></div><p class="src"><a id="v:datatypeInfo" class="def">datatypeInfo</a> :: (<a href="Generics-SOP-GGP.html#t:GDatatypeInfo">GDatatypeInfo</a> a, <a href="Generics-SOP-GGP.html#t:GCode">GCode</a> a ~ <a href="Generics-SOP-Universe.html#t:Code">Code</a> a) =&gt; proxy a -&gt; <a href="Generics-SOP-Metadata.html#t:DatatypeInfo">DatatypeInfo</a> (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a) <a href="src/Generics.SOP.Universe.html#datatypeInfo" class="link">Source</a> <a href="#v:datatypeInfo" class="selflink">#</a></p><div class="doc"><p>Term-level datatype info; by default, the term-level datatype info is produced
 from the type-level info.</p></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:IsProductType" class="def">IsProductType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (xs :: [<a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>]) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Code">Code</a> a ~ '[xs]) <a href="src/Generics.SOP.Universe.html#IsProductType" class="link">Source</a> <a href="#t:IsProductType" class="selflink">#</a></p><div class="doc"><p>Constraint that captures that a datatype is a product type,
 i.e., a type with a single constructor.</p><p>It also gives access to the code for the arguments of that
 constructor.</p><p><em>Since: 0.3.1.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:IsEnumType" class="def">IsEnumType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Constraint.html#t:All">All</a> ((~) '[]) (<a href="Generics-SOP-Universe.html#t:Code">Code</a> a)) <a href="src/Generics.SOP.Universe.html#IsEnumType" class="link">Source</a> <a href="#t:IsEnumType" class="selflink">#</a></p><div class="doc"><p>Constraint that captures that a datatype is an enumeration type,
 i.e., none of the constructors have any arguments.</p><p><em>Since: 0.3.1.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:IsWrappedType" class="def">IsWrappedType</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (x :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:Generic">Generic</a> a, <a href="Generics-SOP-Universe.html#t:Code">Code</a> a ~ '['[x]]) <a href="src/Generics.SOP.Universe.html#IsWrappedType" class="link">Source</a> <a href="#t:IsWrappedType" class="selflink">#</a></p><div class="doc"><p>Constraint that captures that a datatype is a single-constructor,
 single-field datatype. This always holds for newtype-defined types,
 but it can also be true for data-defined types.</p><p>The constraint also gives access to the type that is wrapped.</p><p><em>Since: 0.3.1.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:IsNewtype" class="def">IsNewtype</a> (a :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) (x :: <a href="../base-4.10.1.0/Data-Kind.html#t:-42-">*</a>) = (<a href="Generics-SOP-Universe.html#t:IsWrappedType">IsWrappedType</a> a x, <a href="../base-4.10.1.0/Data-Coerce.html#t:Coercible">Coercible</a> a x) <a href="src/Generics.SOP.Universe.html#IsNewtype" class="link">Source</a> <a href="#t:IsNewtype" class="selflink">#</a></p><div class="doc"><p>Constraint that captures that a datatype is a newtype.
 This makes use of the fact that newtypes are always coercible
 to the type they wrap, whereas datatypes are not.</p><p><em>Since: 0.3.1.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>