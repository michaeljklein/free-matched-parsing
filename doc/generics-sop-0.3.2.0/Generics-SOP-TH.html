<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Generics.SOP.TH</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Generics.SOP.TH.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">generics-sop-0.3.2.0: Generic Programming using True Sums of Products</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Generics.SOP.TH</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Generate <code>generics-sop</code> boilerplate instances using Template Haskell.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:deriveGeneric">deriveGeneric</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:deriveGenericOnly">deriveGenericOnly</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:deriveGenericFunctions">deriveGenericFunctions</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:deriveMetadataValue">deriveMetadataValue</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li><li class="src short"><a href="#v:deriveMetadataType">deriveMetadataType</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:deriveGeneric" class="def">deriveGeneric</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>] <a href="src/Generics.SOP.TH.html#deriveGeneric" class="link">Source</a> <a href="#v:deriveGeneric" class="selflink">#</a></p><div class="doc"><p>Generate <code>generics-sop</code> boilerplate for the given datatype.</p><p>This function takes the name of a datatype and generates:</p><ul><li>a <code><a href="Generics-SOP-Universe.html#t:Code">Code</a></code> instance</li><li>a <code><a href="Generics-SOP-Universe.html#t:Generic">Generic</a></code> instance</li><li>a <code><a href="Generics-SOP-Universe.html#t:HasDatatypeInfo">HasDatatypeInfo</a></code> instance</li></ul><p>Note that the generated code will require the <code>TypeFamilies</code> and
 <code>DataKinds</code> extensions to be enabled for the module.</p><p><em>Example:</em> If you have the datatype</p><pre>data Tree = Leaf Int | Node Tree Tree</pre><p>and say</p><pre>deriveGeneric ''Tree</pre><p>then you get code that is equivalent to:</p><pre>instance Generic Tree where

  type Code Tree = '[ '[Int], '[Tree, Tree] ]

  from (Leaf x)   = SOP (   Z (I x :* Nil))
  from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))

  to (SOP    (Z (I x :* Nil)))         = Leaf x
  to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
  to _ = error &quot;unreachable&quot; -- to avoid GHC warnings

instance HasDatatypeInfo Tree where
  type DatatypeInfoOf Tree =
    T.ADT &quot;Main&quot; &quot;Tree&quot;
      '[ T.Constructor &quot;Leaf&quot;, T.Constructor &quot;Node&quot; ]

  datatypeInfo _ =
    T.demoteDatatypeInfo (Proxy :: Proxy (DatatypeInfoOf Tree))</pre><p><em>Limitations:</em> Generation does not work for GADTs, for
 datatypes that involve existential quantification, for
 datatypes with unboxed fields.</p></div></div><div class="top"><p class="src"><a id="v:deriveGenericOnly" class="def">deriveGenericOnly</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>] <a href="src/Generics.SOP.TH.html#deriveGenericOnly" class="link">Source</a> <a href="#v:deriveGenericOnly" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Generics-SOP-TH.html#v:deriveGeneric">deriveGeneric</a></code>, but omit the <code><a href="Generics-SOP-Universe.html#t:HasDatatypeInfo">HasDatatypeInfo</a></code> instance.</p></div></div><div class="top"><p class="src"><a id="v:deriveGenericFunctions" class="def">deriveGenericFunctions</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>] <a href="src/Generics.SOP.TH.html#deriveGenericFunctions" class="link">Source</a> <a href="#v:deriveGenericFunctions" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Generics-SOP-TH.html#v:deriveGenericOnly">deriveGenericOnly</a></code>, but don't derive class instance, only functions.</p><p><em>Example:</em> If you say</p><pre>deriveGenericFunctions ''Tree &quot;TreeCode&quot; &quot;fromTree&quot; &quot;toTree&quot;</pre><p>then you get code that is equivalent to:</p><pre>type TreeCode = '[ '[Int], '[Tree, Tree] ]

fromTree :: Tree -&gt; SOP I TreeCode
fromTree (Leaf x)   = SOP (   Z (I x :* Nil))
fromTree (Node l r) = SOP (S (Z (I l :* I r :* Nil)))

toTree :: SOP I TreeCode -&gt; Tree
toTree (SOP    (Z (I x :* Nil)))         = Leaf x
toTree (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
toTree _ = error &quot;unreachable&quot; -- to avoid GHC warnings</pre><p><em>Since: 0.2</em></p></div></div><div class="top"><p class="src"><a id="v:deriveMetadataValue" class="def">deriveMetadataValue</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>] <a href="src/Generics.SOP.TH.html#deriveMetadataValue" class="link">Source</a> <a href="#v:deriveMetadataValue" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use <code><a href="Generics-SOP-TH.html#v:deriveMetadataType">deriveMetadataType</a></code> and <code>demoteDatatypeInfo</code> instead.</p></div><p>Derive <code>DatatypeInfo</code> value for the type.</p><p><em>Example:</em> If you say</p><pre>deriveMetadataValue ''Tree &quot;TreeCode&quot; &quot;treeDatatypeInfo&quot;</pre><p>then you get code that is equivalent to:</p><pre>treeDatatypeInfo :: DatatypeInfo TreeCode
treeDatatypeInfo = ADT &quot;Main&quot; &quot;Tree&quot;
    (Constructor &quot;Leaf&quot; :* Constructor &quot;Node&quot; :* Nil)</pre><p><em>Note:</em> CodeType needs to be derived with <code><a href="Generics-SOP-TH.html#v:deriveGenericFunctions">deriveGenericFunctions</a></code>.</p><p><em>Since: 0.2</em></p></div></div><div class="top"><p class="src"><a id="v:deriveMetadataType" class="def">deriveMetadataType</a> :: <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Name">Name</a> -&gt; <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Q">Q</a> [<a href="../template-haskell-2.12.0.0/Language-Haskell-TH-Syntax.html#t:Dec">Dec</a>] <a href="src/Generics.SOP.TH.html#deriveMetadataType" class="link">Source</a> <a href="#v:deriveMetadataType" class="selflink">#</a></p><div class="doc"><p>Derive <code>DatatypeInfo</code> type for the type.</p><p><em>Example:</em> If you say</p><pre>deriveMetadataType ''Tree &quot;TreeDatatypeInfo&quot;</pre><p>then you get code that is equivalent to:</p><pre>type TreeDatatypeInfo =
  T.ADT &quot;Main&quot; &quot;Tree&quot;
    [ T.Constructor &quot;Leaf&quot;, T.Constructor &quot;Node&quot; ]</pre><p><em>Since: 0.3.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>