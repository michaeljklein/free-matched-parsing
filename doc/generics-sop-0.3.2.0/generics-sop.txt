-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic Programming using True Sums of Products
--   
--   A library to support the definition of generic functions. Datatypes
--   are viewed in a uniform, structured way: the choice between
--   constructors is represented using an n-ary sum, and the arguments of
--   each constructor are represented using an n-ary product.
--   
--   The module <a>Generics.SOP</a> is the main module of this library and
--   contains more detailed documentation.
--   
--   Examples of using this library are provided by the following packages:
--   
--   <ul>
--   <li><tt><a>basic-sop</a></tt> basic examples,</li>
--   <li><tt><a>pretty-sop</a></tt> generic pretty printing,</li>
--   <li><tt><a>lens-sop</a></tt> generically computed lenses,</li>
--   <li><tt><a>json-sop</a></tt> generic JSON conversions.</li>
--   </ul>
--   
--   A detailed description of the ideas behind this library is provided by
--   the paper:
--   
--   <ul>
--   <li>Edsko de Vries and Andres LÃ¶h. <a>True Sums of Products</a>.
--   Workshop on Generic Programming (WGP) 2014.</li>
--   </ul>
@package generics-sop
@version 0.3.2.0


-- | Basic functors.
--   
--   Definitions of the type-level equivalents of <a>const</a>, <a>id</a>,
--   and (<a>.</a>), and a definition of the lifted function space.
--   
--   These datatypes are generally useful, but in this library, they're
--   primarily used as parameters for the <tt>NP</tt>, <tt>NS</tt>,
--   <tt>POP</tt>, and <tt>SOP</tt> types.
--   
--   We define own variants of <a>Const</a>, <a>Identity</a> and
--   <a>Compose</a> for various reasons.
--   
--   <ul>
--   <li><a>Const</a> and <a>Compose</a> become kind polymorphic only in
--   <tt>base-4.9.0.0</tt> (<tt>transformers-0.5.0.0</tt>).</li>
--   <li>Shorter names are convenient, and pattern synonyms aren't (yet)
--   powerful enough, particularly exhaustiveness check doesn't work
--   properly. See
--   <a>https://ghc.haskell.org/trac/ghc/ticket/8779</a>.</li>
--   </ul>
module Generics.SOP.BasicFunctors

-- | The constant type functor.
--   
--   Like <a>Constant</a>, but kind-polymorphic in its second argument and
--   with a shorter name.
newtype K (a :: *) (b :: k)
K :: a -> K

-- | Extract the contents of a <a>K</a> value.
unK :: K a b -> a

-- | The identity type functor.
--   
--   Like <a>Identity</a>, but with a shorter name.
newtype I (a :: *)
I :: a -> I

-- | Extract the contents of an <a>I</a> value.
unI :: I a -> a

-- | Composition of functors.
--   
--   Like <a>Compose</a>, but kind-polymorphic and with a shorter name.
newtype (:.:) (f :: l -> *) (g :: k -> l) (p :: k)
Comp :: (f (g p)) -> (:.:)

-- | Extract the contents of a <a>Comp</a> value.
unComp :: (f :.: g) p -> f (g p)

-- | Lift the given function.
mapII :: (a -> b) -> I a -> I b

-- | Lift the given function.
mapIK :: (a -> b) -> I a -> K b c

-- | Lift the given function.
mapKI :: (a -> b) -> K a c -> I b

-- | Lift the given function.
mapKK :: (a -> b) -> K a c -> K b d

-- | Lift the given function.
mapIII :: (a -> b -> c) -> I a -> I b -> I c

-- | Lift the given function.
mapIIK :: (a -> b -> c) -> I a -> I b -> K c d

-- | Lift the given function.
mapIKI :: (a -> b -> c) -> I a -> K b d -> I c

-- | Lift the given function.
mapIKK :: (a -> b -> c) -> I a -> K b d -> K c e

-- | Lift the given function.
mapKII :: (a -> b -> c) -> K a d -> I b -> I c

-- | Lift the given function.
mapKIK :: (a -> b -> c) -> K a d -> I b -> K c e

-- | Lift the given function.
mapKKI :: (a -> b -> c) -> K a d -> K b e -> I c

-- | Lift the given function.
mapKKK :: (a -> b -> c) -> K a d -> K b e -> K c f
instance forall l (f :: l -> *) k (g :: k -> l) (p :: k). GHC.Generics.Generic ((Generics.SOP.BasicFunctors.:.:) f g p)
instance GHC.Generics.Generic (Generics.SOP.BasicFunctors.I a)
instance Data.Traversable.Traversable Generics.SOP.BasicFunctors.I
instance Data.Foldable.Foldable Generics.SOP.BasicFunctors.I
instance GHC.Base.Functor Generics.SOP.BasicFunctors.I
instance forall a k (b :: k). GHC.Generics.Generic (Generics.SOP.BasicFunctors.K a b)
instance Data.Traversable.Traversable (Generics.SOP.BasicFunctors.K a)
instance Data.Foldable.Foldable (Generics.SOP.BasicFunctors.K a)
instance GHC.Base.Functor (Generics.SOP.BasicFunctors.K a)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (f Generics.SOP.BasicFunctors.:.: g)
instance (GHC.Base.Applicative f, GHC.Base.Applicative g) => GHC.Base.Applicative (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Foldable.Foldable f, Data.Foldable.Foldable g) => Data.Foldable.Foldable (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Traversable.Traversable f, Data.Traversable.Traversable g) => Data.Traversable.Traversable (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Functor.Classes.Eq1 (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Functor.Classes.Ord1 (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Functor.Classes.Read1 (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Functor.Classes.Show1 (f Generics.SOP.BasicFunctors.:.: g)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g, GHC.Classes.Eq a) => GHC.Classes.Eq ((Generics.SOP.BasicFunctors.:.:) f g a)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g, GHC.Classes.Ord a) => GHC.Classes.Ord ((Generics.SOP.BasicFunctors.:.:) f g a)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g, GHC.Read.Read a) => GHC.Read.Read ((Generics.SOP.BasicFunctors.:.:) f g a)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g, GHC.Show.Show a) => GHC.Show.Show ((Generics.SOP.BasicFunctors.:.:) f g a)
instance forall k l (f :: l -> *) (g :: k -> l) (a :: k). Control.DeepSeq.NFData (f (g a)) => Control.DeepSeq.NFData ((Generics.SOP.BasicFunctors.:.:) f g a)
instance (Control.DeepSeq.NFData1 f, Control.DeepSeq.NFData1 g) => Control.DeepSeq.NFData1 (f Generics.SOP.BasicFunctors.:.: g)
instance GHC.Base.Applicative Generics.SOP.BasicFunctors.I
instance GHC.Base.Monad Generics.SOP.BasicFunctors.I
instance Data.Functor.Classes.Eq1 Generics.SOP.BasicFunctors.I
instance Data.Functor.Classes.Ord1 Generics.SOP.BasicFunctors.I
instance Data.Functor.Classes.Read1 Generics.SOP.BasicFunctors.I
instance Data.Functor.Classes.Show1 Generics.SOP.BasicFunctors.I
instance GHC.Classes.Eq a => GHC.Classes.Eq (Generics.SOP.BasicFunctors.I a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Generics.SOP.BasicFunctors.I a)
instance GHC.Read.Read a => GHC.Read.Read (Generics.SOP.BasicFunctors.I a)
instance GHC.Show.Show a => GHC.Show.Show (Generics.SOP.BasicFunctors.I a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Generics.SOP.BasicFunctors.I a)
instance Control.DeepSeq.NFData1 Generics.SOP.BasicFunctors.I
instance Data.Functor.Classes.Eq2 Generics.SOP.BasicFunctors.K
instance Data.Functor.Classes.Ord2 Generics.SOP.BasicFunctors.K
instance Data.Functor.Classes.Read2 Generics.SOP.BasicFunctors.K
instance Data.Functor.Classes.Show2 Generics.SOP.BasicFunctors.K
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Generics.SOP.BasicFunctors.K a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Generics.SOP.BasicFunctors.K a)
instance GHC.Read.Read a => Data.Functor.Classes.Read1 (Generics.SOP.BasicFunctors.K a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Generics.SOP.BasicFunctors.K a)
instance forall k a (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Generics.SOP.BasicFunctors.K a b)
instance forall k a (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Generics.SOP.BasicFunctors.K a b)
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Generics.SOP.BasicFunctors.K a b)
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Generics.SOP.BasicFunctors.K a b)
instance GHC.Base.Monoid a => GHC.Base.Applicative (Generics.SOP.BasicFunctors.K a)
instance forall k a (b :: k). Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Generics.SOP.BasicFunctors.K a b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData1 (Generics.SOP.BasicFunctors.K a)
instance Control.DeepSeq.NFData2 Generics.SOP.BasicFunctors.K


-- | Singleton types corresponding to type-level data structures.
--   
--   The implementation is similar, but subtly different to that of the
--   <tt><a>singletons</a></tt> package. See the <a>"True Sums of
--   Products"</a> paper for details.
module Generics.SOP.Sing

-- | Explicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over. For every
--   type-level list <tt>xs</tt>, there is one non-bottom value of type
--   <tt><a>SList</a> xs</tt>.
--   
--   Note that these singleton lists are polymorphic in the list elements;
--   we do not require a singleton representation for them.
data SList :: [k] -> *
[SNil] :: SList '[]
[SCons] :: SListI xs => SList (x : xs)

-- | Implicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over.
--   
--   The class <a>SListI</a> should have instances that match the
--   constructors of <a>SList</a>.
class SListI (xs :: [k])

-- | Get hold of the explicit singleton (that one can then pattern match
--   on).
sList :: SListI xs => SList xs

-- | Explicit singleton type.
--   
--   Just provided for limited backward compatibility.

-- | <i>Deprecated: Use <a>SList</a> instead.</i>
type Sing = SList

-- | General class for implicit singletons.
--   
--   Just provided for limited backward compatibility.

-- | <i>Deprecated: Use <a>SListI</a> instead.</i>
class SListI xs => SingI (xs :: [k])

-- | <i>Deprecated: Use <a>sList</a> instead.</i>
sing :: SingI xs => Sing xs

-- | Occassionally it is useful to have an explicit, term-level,
--   representation of type-level lists (esp because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9108)</a>
data Shape :: [k] -> *
[ShapeNil] :: Shape '[]
[ShapeCons] :: SListI xs => Shape xs -> Shape (x : xs)

-- | The shape of a type-level list.
shape :: forall (xs :: [k]). SListI xs => Shape xs

-- | The length of a type-level list.
lengthSList :: forall (xs :: [k]) proxy. SListI xs => proxy xs -> Int

-- | Old name for <a>lengthSList</a>.

-- | <i>Deprecated: Use <a>lengthSList</a> instead.</i>
lengthSing :: SListI xs => proxy xs -> Int
instance forall k (xs :: [k]). GHC.Show.Show (Generics.SOP.Sing.SList xs)
instance forall k (xs :: [k]). GHC.Classes.Eq (Generics.SOP.Sing.SList xs)
instance forall k (xs :: [k]). GHC.Classes.Ord (Generics.SOP.Sing.SList xs)
instance forall k (xs :: [k]). GHC.Show.Show (Generics.SOP.Sing.Shape xs)
instance forall k (xs :: [k]). GHC.Classes.Eq (Generics.SOP.Sing.Shape xs)
instance forall k (xs :: [k]). GHC.Classes.Ord (Generics.SOP.Sing.Shape xs)
instance Generics.SOP.Sing.SListI '[]
instance forall k (xs :: [k]) (x :: k). Generics.SOP.Sing.SListI xs => Generics.SOP.Sing.SListI (x : xs)


-- | Constraints for indexed datatypes.
--   
--   This module contains code that helps to specify that all elements of
--   an indexed structure must satisfy a particular constraint.
module Generics.SOP.Constraint

-- | Require a constraint for every element of a list.
--   
--   If you have a datatype that is indexed over a type-level list, then
--   you can use <a>All</a> to indicate that all elements of that
--   type-level list must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All Eq '[ Int, Bool, Char ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All Eq xs =&gt; NP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the n-ary
--   product satisfy <a>Eq</a>.
class (AllF f xs, SListI xs) => All (f :: k -> Constraint) (xs :: [k])

-- | Type family used to implement <a>All</a>.

-- | Require a singleton for every inner list in a list of lists.
type SListI2 = All SListI

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the innert lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.
class (AllF (All f) xss, SListI xss) => All2 f xss

-- | Require a constraint for pointwise for every pair of elements from two
--   lists.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All (~) '[ Int, Bool, Char ] '[ a, b, c ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Int ~ a, Bool ~ b, Char ~ c)
--   </pre>
class (SListI xs, SListI ys, SameShapeAs xs ys, SameShapeAs ys xs, AllZipF c xs ys) => AllZip (c :: a -> b -> Constraint) (xs :: [a]) (ys :: [b])

-- | Type family used to implement <a>AllZip</a>.

-- | Type family that forces a type-level list to be of the same shape as
--   the given type-level list.
--   
--   The main use of this constraint is to help type inference to learn
--   something about otherwise unknown type-level lists.

-- | Utility function to compute the head of a type-level list.

-- | Utility function to compute the tail of a type-level list.

-- | The constraint <tt>LiftedCoercible f g x y</tt> is equivalent to
--   <tt>Coercible (f x) (g y)</tt>.
class Coercible (f x) (g y) => LiftedCoercible f g x y

-- | Require a constraint for pointwise for every pair of elements from two
--   lists of lists.
class (AllZipF (AllZip f) xss yss, SListI xss, SListI yss, SameShapeAs xss yss, SameShapeAs yss xss) => AllZip2 f xss yss

-- | Composition of constraints.
--   
--   Note that the result of the composition must be a constraint, and
--   therefore, in <tt>f <tt>:.</tt> g</tt>, the kind of <tt>f</tt> is
--   <tt>k -&gt; <a>Constraint</a></tt>. The kind of <tt>g</tt>, however,
--   is <tt>l -&gt; k</tt> and can thus be an normal type constructor.
--   
--   A typical use case is in connection with <a>All</a> on an <tt>NP</tt>
--   or an <tt>NS</tt>. For example, in order to denote that all elements
--   on an <tt><tt>NP</tt> f xs</tt> satisfy <a>Show</a>, we can say
--   <tt><a>All</a> (<a>Show</a> :. f) xs</tt>.
class (f (g x)) => f `Compose` g x

-- | Pairing of constraints.
class (f x, g x) => f `And` g x

-- | A constraint that can always be satisfied.
class Top x

-- | A generalization of <a>All</a> and <a>All2</a>.
--   
--   The family <a>AllN</a> expands to <a>All</a> or <a>All2</a> depending
--   on whether the argument is indexed by a list or a list of lists.

-- | A generalization of <a>AllZip</a> and <a>AllZip2</a>.
--   
--   The family <a>AllZipN</a> expands to <a>AllZip</a> or <a>AllZip2</a>
--   depending on whther the argument is indexed by a list or a list of
--   lists.

-- | A generalization of <a>SListI</a>.
--   
--   The family <a>SListIN</a> expands to <a>SListI</a> or <a>SListI2</a>
--   depending on whether the argument is indexed by a list or a list of
--   lists.

-- | The kind of constraints, like <tt>Show a</tt>
data Constraint :: *
instance forall k (x :: k). Generics.SOP.Constraint.Top x
instance forall k (f :: k -> GHC.Types.Constraint) (x :: k) (g :: k -> GHC.Types.Constraint). (f x, g x) => Generics.SOP.Constraint.And f g x
instance forall k1 k2 (f :: k2 -> GHC.Types.Constraint) (g :: k1 -> k2) (x :: k1). f (g x) => Generics.SOP.Constraint.Compose f g x
instance forall a b (f :: a -> b -> GHC.Types.Constraint) (xss :: [[a]]) (yss :: [[b]]). (Generics.SOP.Constraint.AllZipF (Generics.SOP.Constraint.AllZip f) xss yss, Generics.SOP.Sing.SListI xss, Generics.SOP.Sing.SListI yss, Generics.SOP.Constraint.SameShapeAs xss yss, Generics.SOP.Constraint.SameShapeAs yss xss) => Generics.SOP.Constraint.AllZip2 f xss yss
instance forall k1 k2 k0 (f :: k2 -> k0) (x :: k2) (g :: k1 -> k0) (y :: k1). GHC.Types.Coercible (f x) (g y) => Generics.SOP.Constraint.LiftedCoercible f g x y
instance forall b a (xs :: [a]) (ys :: [b]) (c :: a -> b -> GHC.Types.Constraint). (Generics.SOP.Sing.SListI xs, Generics.SOP.Sing.SListI ys, Generics.SOP.Constraint.SameShapeAs xs ys, Generics.SOP.Constraint.SameShapeAs ys xs, Generics.SOP.Constraint.AllZipF c xs ys) => Generics.SOP.Constraint.AllZip c xs ys
instance forall k (f :: k -> GHC.Types.Constraint) (xss :: [[k]]). (Generics.SOP.Constraint.AllF (Generics.SOP.Constraint.All f) xss, Generics.SOP.Sing.SListI xss) => Generics.SOP.Constraint.All2 f xss
instance forall k (f :: k -> GHC.Types.Constraint) (xs :: [k]). (Generics.SOP.Constraint.AllF f xs, Generics.SOP.Sing.SListI xs) => Generics.SOP.Constraint.All f xs
instance forall k (xss :: [[k]]). (Generics.SOP.Constraint.All Generics.SOP.Sing.SListI xss, Generics.SOP.Sing.SListI xss) => Generics.SOP.Sing.SingI xss
instance forall k (xs :: [k]). Generics.SOP.Sing.SListI xs => Generics.SOP.Sing.SingI xs


-- | Classes for generalized combinators on SOP types.
--   
--   In the SOP approach to generic programming, we're predominantly
--   concerned with four structured datatypes:
--   
--   <pre>
--   <a>NP</a>  :: (k -&gt; *) -&gt; ( [k]  -&gt; *)   -- n-ary product
--   <a>NS</a>  :: (k -&gt; *) -&gt; ( [k]  -&gt; *)   -- n-ary sum
--   <a>POP</a> :: (k -&gt; *) -&gt; ([[k]] -&gt; *)   -- product of products
--   <a>SOP</a> :: (k -&gt; *) -&gt; ([[k]] -&gt; *)   -- sum of products
--   </pre>
--   
--   All of these have a kind that fits the following pattern:
--   
--   <pre>
--   (k -&gt; *) -&gt; (l -&gt; *)
--   </pre>
--   
--   These four types support similar interfaces. In order to allow reusing
--   the same combinator names for all of these types, we define various
--   classes in this module that allow the necessary generalization.
--   
--   The classes typically lift concepts that exist for kinds <tt>*</tt> or
--   <tt>* -&gt; *</tt> to datatypes of kind <tt>(k -&gt; *) -&gt; (l -&gt;
--   *)</tt>. This module also derives a number of derived combinators.
--   
--   The actual instances are defined in <a>Generics.SOP.NP</a> and
--   <a>Generics.SOP.NS</a>.
module Generics.SOP.Classes

-- | A generalization of <a>pure</a> or <a>return</a> to higher kinds.
class HPure (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>pure</a> directly.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hpure</a>, <a>pure_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a) -&gt; <a>NP</a>  f xs
--   <a>hpure</a>, <a>pure_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a) -&gt; <a>POP</a> f xss
--   </pre>
hpure :: (HPure h, SListIN h xs) => (forall a. f a) -> h f xs

-- | A variant of <a>hpure</a> that allows passing in a constrained
--   argument.
--   
--   Calling <tt><a>hcpure</a> f s</tt> where <tt>s :: h f xs</tt> causes
--   <tt>f</tt> to be applied at all the types that are contained in
--   <tt>xs</tt>. Therefore, the constraint <tt>c</tt> has to be satisfied
--   for all elements of <tt>xs</tt>, which is what <tt><tt>AllMap</tt> h c
--   xs</tt> states.
--   
--   Morally, <a>hpure</a> is a special case of <a>hcpure</a> where the
--   constraint is empty. However, it is in the nature of how
--   <tt>AllMap</tt> is defined as well as current GHC limitations that it
--   is tricky to prove to GHC in general that <tt><tt>AllMap</tt> h c
--   NoConstraint xs</tt> is always satisfied. Therefore, we typically
--   define <a>hpure</a> separately and directly, and make it a member of
--   the class.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcpure</a>, <a>cpure_NP</a>  :: (<a>All</a>  c xs ) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>NP</a>  f xs
--   <a>hcpure</a>, <a>cpure_POP</a> :: (<a>All2</a> c xss) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>POP</a> f xss
--   </pre>
hcpure :: (HPure h, (AllN h c xs)) => proxy c -> (forall a. c a => f a) -> h f xs

-- | Lifted functions.
newtype f (-.->) g a
Fn :: (f a -> g a) -> (-.->) f g a
[apFn] :: (-.->) f g a -> f a -> g a

-- | Construct a lifted function.
--   
--   Same as <a>Fn</a>. Only available for uniformity with the higher-arity
--   versions.
fn :: (f a -> f' a) -> (f -.-> f') a

-- | Construct a binary lifted function.
fn_2 :: (f a -> f' a -> f'' a) -> (f -.-> (f' -.-> f'')) a

-- | Construct a ternary lifted function.
fn_3 :: (f a -> f' a -> f'' a -> f''' a) -> (f -.-> (f' -.-> (f'' -.-> f'''))) a

-- | Construct a quarternary lifted function.
fn_4 :: (f a -> f' a -> f'' a -> f''' a -> f'''' a) -> (f -.-> (f' -.-> (f'' -.-> (f''' -.-> f'''')))) a

-- | Maps a structure to the same structure.

-- | Maps a structure containing sums to the corresponding product
--   structure.

-- | A generalization of <a>&lt;*&gt;</a>.
class (Prod (Prod h) ~ Prod h, HPure (Prod h)) => HAp (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>&lt;*&gt;</a>.
--   
--   For products (<a>NP</a>) as well as products of products (<a>POP</a>),
--   the correspondence is rather direct. We combine a structure containing
--   (lifted) functions and a compatible structure containing corresponding
--   arguments into a compatible structure containing results.
--   
--   The same combinator can also be used to combine a product structure of
--   functions with a sum structure of arguments, which then results in
--   another sum structure of results. The sum structure determines which
--   part of the product structure will be used.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hap</a>, <a>ap_NP</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  g xs
--   <a>hap</a>, <a>ap_NS</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  g xs
--   <a>hap</a>, <a>ap_POP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>POP</a> f xss -&gt; <a>POP</a> g xss
--   <a>hap</a>, <a>ap_SOP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> g xss
--   </pre>
hap :: HAp h => Prod h (f -.-> g) xs -> h f xs -> h g xs

-- | A generalized form of <a>liftA</a>, which in turn is a generalized
--   <a>map</a>.
--   
--   Takes a lifted function and applies it to every element of a structure
--   while preserving its shape.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA</a> f xs = <a>hpure</a> (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA</a>, <a>liftA_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs
--   <a>hliftA</a>, <a>liftA_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  f' xs
--   <a>hliftA</a>, <a>liftA_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss
--   <a>hliftA</a>, <a>liftA_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> f' xss
--   </pre>
hliftA :: (SListIN (Prod h) xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | A generalized form of <a>liftA2</a>, which in turn is a generalized
--   <a>zipWith</a>.
--   
--   Takes a lifted binary function and uses it to combine two structures
--   of equal shape into a single structure.
--   
--   It either takes two product structures to a product structure, or one
--   product and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA2</a> f xs ys = <a>hpure</a> (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA2</a>, <a>liftA2_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NS</a>  f' xs  -&gt; <a>NS</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss
--   <a>hliftA2</a>, <a>liftA2_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>SOP</a> f' xss -&gt; <a>SOP</a> f'' xss
--   </pre>
hliftA2 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | A generalized form of <a>liftA3</a>, which in turn is a generalized
--   <a>zipWith3</a>.
--   
--   Takes a lifted ternary function and uses it to combine three
--   structures of equal shape into a single structure.
--   
--   It either takes three product structures to a product structure, or
--   two product structures and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA3</a> f xs ys zs = <a>hpure</a> (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA3</a>, <a>liftA3_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs  -&gt; <a>NP</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NS</a>  f'' xs  -&gt; <a>NS</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss -&gt; <a>POP</a> f''' xs
--   <a>hliftA3</a>, <a>liftA3_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>SOP</a> f'' xss -&gt; <a>SOP</a> f''' xs
--   </pre>
hliftA3 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hliftA</a>.
hmap :: (SListIN (Prod h) xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hliftA2</a>.
hzipWith :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hliftA3</a>.
hzipWith3 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Variant of <a>hliftA</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA</a> p f xs = <a>hcpure</a> p (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
hcliftA :: (AllN (Prod h) c xs, HAp h) => proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Variant of <a>hcliftA2</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA2</a> p f xs ys = <a>hcpure</a> p (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
hcliftA2 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Variant of <a>hcliftA3</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA3</a> p f xs ys zs = <a>hcpure</a> p (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
hcliftA3 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hcliftA</a>.
hcmap :: (AllN (Prod h) c xs, HAp h) => proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hcliftA2</a>.
hczipWith :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hcliftA3</a>.
hczipWith3 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Maps products to lists, and sums to identities.

-- | A class for collapsing a heterogeneous structure into a homogeneous
--   one.
class HCollapse (h :: (k -> *) -> (l -> *))

-- | Collapse a heterogeneous structure with homogeneous elements into a
--   homogeneous structure.
--   
--   If a heterogeneous structure is instantiated to the constant functor
--   <a>K</a>, then it is in fact homogeneous. This function maps such a
--   value to a simpler Haskell datatype reflecting that. An
--   <tt><tt>NS</tt> (<a>K</a> a)</tt> contains a single <tt>a</tt>, and an
--   <tt><tt>NP</tt> (<a>K</a> a)</tt> contains a list of <tt>a</tt>s.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcollapse</a>, <a>collapse_NP</a>  :: <a>NP</a>  (<a>K</a> a) xs  -&gt;  [a]
--   <a>hcollapse</a>, <a>collapse_NS</a>  :: <a>NS</a>  (<a>K</a> a) xs  -&gt;   a
--   <a>hcollapse</a>, <a>collapse_POP</a> :: <a>POP</a> (<a>K</a> a) xss -&gt; [[a]]
--   <a>hcollapse</a>, <a>collapse_SOP</a> :: <a>SOP</a> (<a>K</a> a) xss -&gt;  [a]
--   </pre>
hcollapse :: (HCollapse h, SListIN h xs) => h (K a) xs -> CollapseTo h a

-- | A generalization of <a>traverse_</a> or <a>foldMap</a>.
class HTraverse_ (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>traverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse_</a>, <a>ctraverse__NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
hctraverse_ :: (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g ()) -> h f xs -> g ()

-- | Unconstrained version of <a>hctraverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <tt>traverse_</tt>, <a>traverse__NP</a>  :: (<tt>SListI</tt>  xs , 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__NS</a>  :: (<tt>SListI</tt>  xs , 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__POP</a> :: (<a>SListI2</a> xss, 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__SOP</a> :: (<a>SListI2</a> xss, 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
htraverse_ :: (HTraverse_ h, SListIN h xs, Applicative g) => (forall a. f a -> g ()) -> h f xs -> g ()

-- | A generalization of <a>sequenceA</a>.
class HAp h => HSequence (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>sequenceA</a>.
--   
--   Lifts an applicative functor out of a structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hsequence'</a>, <a>sequence'_NP</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NP</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NP</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_NS</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NS</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NS</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_POP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>POP</a> (f <a>:.:</a> g) xss -&gt; f (<a>POP</a> g xss)
--   <a>hsequence'</a>, <a>sequence'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>SOP</a> (f <a>:.:</a> g) xss -&gt; f (<a>SOP</a> g xss)
--   </pre>
hsequence' :: (HSequence h, SListIN h xs, Applicative f) => h (f :.: g) xs -> f (h g xs)

-- | Corresponds to <a>traverse</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse'</a>, <a>ctraverse'_NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>hctraverse'</a>, <a>ctraverse'_SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
hctraverse' :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Unconstrained variant of <a>htraverse'</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>htraverse'</a>, <a>traverse'_NP</a>  :: (<tt>SListI</tt>  xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_NS</a>  :: (<a>SListI2</a> xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_POP</a> :: (<tt>SListI</tt>  xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>htraverse'</a>, <a>traverse'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
htraverse' :: (HSequence h, SListIN h xs, Applicative g) => (forall a. f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Special case of <a>hctraverse_</a>.
hcfoldMap :: (HTraverse_ h, AllN h c xs, Monoid m) => proxy c -> (forall a. c a => f a -> m) -> h f xs -> m

-- | Flipped version of <a>hctraverse_</a>.
hcfor_ :: (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall a. c a => f a -> g ()) -> g ()

-- | Special case of <a>hsequence'</a> where <tt>g = <a>I</a></tt>.
hsequence :: (SListIN h xs, SListIN (Prod h) xs, HSequence h) => Applicative f => h f xs -> f (h I xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>K</a> a</tt>.
hsequenceK :: (SListIN h xs, SListIN (Prod h) xs, Applicative f, HSequence h) => h (K (f a)) xs -> f (h (K a) xs)

-- | Special case of <a>hctraverse'</a> where <tt>f' = <a>I</a></tt>.
hctraverse :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> h f xs -> g (h I xs)

-- | Flipped version of <a>hctraverse</a>.
hcfor :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall a. c a => f a -> g a) -> g (h I xs)

-- | A class for determining which choice in a sum-like structure a value
--   represents.
class HIndex (h :: (k -> *) -> (l -> *))

-- | If <tt>h</tt> is a sum-like structure representing a choice between
--   <tt>n</tt> different options, and <tt>x</tt> is a value of type <tt>h
--   f xs</tt>, then <tt><a>hindex</a> x</tt> returns a number between
--   <tt>0</tt> and <tt>n - 1</tt> representing the index of the choice
--   made by <tt>x</tt>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hindex</a>, <a>index_NS</a>  :: <a>NS</a>  f xs -&gt; Int
--   <a>hindex</a>, <a>index_SOP</a> :: <a>SOP</a> f xs -&gt; Int
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hindex (S (S (Z (I False))))
--   2
--   
--   &gt;&gt;&gt; hindex (Z (K ()))
--   0
--   
--   &gt;&gt;&gt; hindex (SOP (S (Z (I True :* I 'x' :* Nil))))
--   1
--   </pre>
hindex :: HIndex h => h f xs -> Int

-- | Maps a structure containing products to the corresponding sum
--   structure.

-- | A class for applying all injections corresponding to a sum-like
--   structure to a table containing suitable arguments.
class (UnProd (Prod h) ~ h) => HApInjs (h :: (k -> *) -> (l -> *))

-- | For a given table (product-like structure), produce a list where each
--   element corresponds to the application of an injection function into
--   the corresponding sum-like structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hapInjs</a>, <a>apInjs_NP</a>  :: <a>SListI</a>  xs  =&gt; <a>NP</a>  f xs -&gt; [<a>NS</a>  f xs ]
--   <a>hapInjs</a>, <a>apInjs_SOP</a> :: <a>SListI2</a> xss =&gt; <a>POP</a> f xs -&gt; [<a>SOP</a> f xss]
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (I 'x' :* I True :* I 2 :* Nil) :: [NS I '[Char, Bool, Int]]
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil)) :: [SOP I '[ '[Char], '[Bool, Int]]]
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
--   
--   Unfortunately the type-signatures are required in GHC-7.10 and older.
hapInjs :: (HApInjs h, (SListIN h xs)) => Prod h f xs -> [h f xs]

-- | A class for expanding sum structures into corresponding product
--   structures, filling in the slots not targeted by the sum with default
--   values.
class HExpand (h :: (k -> *) -> (l -> *))

-- | Expand a given sum structure into a corresponding product structure by
--   placing the value contained in the sum into the corresponding position
--   in the product, and using the given default value for all other
--   positions.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hexpand</a>, <a>expand_NS</a>  :: <a>SListI</a> xs  =&gt; (forall x . f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hexpand</a>, <a>expand_SOP</a> :: <a>SListI2</a> xss =&gt; (forall x . f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hexpand Nothing (S (Z (Just 3))) :: NP Maybe '[Char, Int, Bool]
--   Nothing :* Just 3 :* Nothing :* Nil
--   
--   &gt;&gt;&gt; hexpand [] (SOP (S (Z ([1,2] :* "xyz" :* Nil)))) :: POP [] '[ '[Bool], '[Int, Char] ]
--   POP (([] :* Nil) :* ([1,2] :* "xyz" :* Nil) :* Nil)
--   </pre>
hexpand :: (HExpand h, (SListIN (Prod h) xs)) => (forall x. f x) -> h f xs -> Prod h f xs

-- | Variant of <a>hexpand</a> that allows passing a constrained default.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcexpand</a>, <a>cexpand_NS</a>  :: <a>All</a>  c xs  =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hcexpand</a>, <a>cexpand_SOP</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Bounded) (I minBound) (S (Z (I 20))) :: NP I '[Bool, Int, Ordering]
--   I False :* I 20 :* I LT :* Nil
--   
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Num) (I 0) (SOP (S (Z (I 1 :* I 2 :* Nil)))) :: POP I '[ '[Double], '[Int, Int] ]
--   POP ((I 0.0 :* Nil) :* (I 1 :* I 2 :* Nil) :* Nil)
--   </pre>
hcexpand :: (HExpand h, (AllN (Prod h) c xs)) => proxy c -> (forall x. c x => f x) -> h f xs -> Prod h f xs

-- | A class for transforming structures into related structures with a
--   different index list, as long as the index lists have the same shape
--   and the elements and interpretation functions are suitably related.
class (Same h1 ~ h2, Same h2 ~ h1) => HTrans (h1 :: (k1 -> *) -> (l1 -> *)) (h2 :: (k2 -> *) -> (l2 -> *))

-- | Transform a structure into a related structure given a conversion
--   function for the elements.
htrans :: (HTrans h1 h2, AllZipN (Prod h1) c xs ys) => proxy c -> (forall x y. c x y => f x -> g y) -> h1 f xs -> h2 g ys

-- | Coerce a structure into a representationally equal structure.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcoerce (I (Just LT) :* I (Just 'x') :* I (Just True) :* Nil) :: NP Maybe '[Ordering, Char, Bool]
--   Just LT :* Just 'x' :* Just True :* Nil
--   
--   &gt;&gt;&gt; hcoerce (SOP (Z (K True :* K False :* Nil))) :: SOP I '[ '[Bool, Bool], '[Bool] ]
--   SOP (Z (I True :* I False :* Nil))
--   </pre>
hcoerce :: (HTrans h1 h2, AllZipN (Prod h1) (LiftedCoercible f g) xs ys, HTrans h1 h2) => h1 f xs -> h2 g ys

-- | Specialization of <a>hcoerce</a>.
hfromI :: (AllZipN (Prod h1) (LiftedCoercible I f) xs ys, HTrans h1 h2) => h1 I xs -> h2 f ys

-- | Specialization of <a>hcoerce</a>.
htoI :: (AllZipN (Prod h1) (LiftedCoercible f I) xs ys, HTrans h1 h2) => h1 f xs -> h2 I ys


-- | n-ary products (and products of products)
module Generics.SOP.NP

-- | An n-ary product.
--   
--   The product is parameterized by a type constructor <tt>f</tt> and
--   indexed by a type-level list <tt>xs</tt>. The length of the list
--   determines the number of elements in the product, and if the
--   <tt>i</tt>-th element of the list is of type <tt>x</tt>, then the
--   <tt>i</tt>-th element of the product is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble the names of the list
--   constructors.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the product
--   becomes a heterogeneous list, where the type-level list describes the
--   types of its components. For <tt><a>K</a> a</tt>, the product becomes
--   a homogeneous list, where the contents of the type-level list are
--   ignored, but its length still specifies the number of elements.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   product describes the structure of the arguments of a single data
--   constructor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   I 'x'    :* I True  :* Nil  ::  NP I       '[ Char, Bool ]
--   K 0      :* K 1     :* Nil  ::  NP (K Int) '[ Char, Bool ]
--   Just 'x' :* Nothing :* Nil  ::  NP Maybe   '[ Char, Bool ]
--   </pre>
data NP :: (k -> *) -> [k] -> *
[Nil] :: NP f '[]
[:*] :: f x -> NP f xs -> NP f (x : xs)

-- | A product of products.
--   
--   This is a 'newtype' for an <a>NP</a> of an <a>NP</a>. The elements of
--   the inner products are applications of the parameter <tt>f</tt>. The
--   type <a>POP</a> is indexed by the list of lists that determines the
--   lengths of both the outer and all the inner products, as well as the
--   types of all the elements of the inner products.
--   
--   A <a>POP</a> is reminiscent of a two-dimensional table (but the inner
--   lists can all be of different length). In the context of the SOP
--   approach to generic programming, a <a>POP</a> is useful to represent
--   information that is available for all arguments of all constructors of
--   a datatype.
newtype POP (f :: (k -> *)) (xss :: [[k]])
POP :: (NP (NP f) xss) -> POP

-- | Unwrap a product of products.
unPOP :: POP f xss -> NP (NP f) xss

-- | Specialization of <a>hpure</a>.
--   
--   The call <tt><a>pure_NP</a> x</tt> generates a product that contains
--   <tt>x</tt> in every element position.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; pure_NP [] :: NP [] '[Char, Bool]
--   "" :* [] :* Nil
--   
--   &gt;&gt;&gt; pure_NP (K 0) :: NP (K Int) '[Double, Int, String]
--   K 0 :* K 0 :* K 0 :* Nil
--   </pre>
pure_NP :: forall f xs. SListI xs => (forall a. f a) -> NP f xs

-- | Specialization of <a>hpure</a>.
--   
--   The call <tt><a>pure_POP</a> x</tt> generates a product of products
--   that contains <tt>x</tt> in every element position.
pure_POP :: All SListI xss => (forall a. f a) -> POP f xss

-- | Specialization of <a>hcpure</a>.
--   
--   The call <tt><a>cpure_NP</a> p x</tt> generates a product that
--   contains <tt>x</tt> in every element position.
cpure_NP :: forall c xs proxy f. All c xs => proxy c -> (forall a. c a => f a) -> NP f xs

-- | Specialization of <a>hcpure</a>.
--   
--   The call <tt><a>cpure_NP</a> p x</tt> generates a product of products
--   that contains <tt>x</tt> in every element position.
cpure_POP :: forall c xss proxy f. All2 c xss => proxy c -> (forall a. c a => f a) -> POP f xss

-- | Construct a homogeneous n-ary product from a normal Haskell list.
--   
--   Returns <a>Nothing</a> if the length of the list does not exactly
--   match the expected size of the product.
fromList :: SListI xs => [a] -> Maybe (NP (K a) xs)

-- | Specialization of <a>hap</a>.
--   
--   Applies a product of (lifted) functions pointwise to a product of
--   suitable arguments.
ap_NP :: NP (f -.-> g) xs -> NP f xs -> NP g xs

-- | Specialization of <a>hap</a>.
--   
--   Applies a product of (lifted) functions pointwise to a product of
--   suitable arguments.
ap_POP :: POP (f -.-> g) xss -> POP f xss -> POP g xss

-- | Obtain the head of an n-ary product.
hd :: NP f (x : xs) -> f x

-- | Obtain the tail of an n-ary product.
tl :: NP f (x : xs) -> NP f xs

-- | The type of projections from an n-ary product.
type Projection (f :: k -> *) (xs :: [k]) = K (NP f xs) -.-> f

-- | Compute all projections from an n-ary product.
--   
--   Each element of the resulting product contains one of the projections.
projections :: forall xs f. SListI xs => NP (Projection f xs) xs
shiftProjection :: Projection f xs a -> Projection f (x : xs) a

-- | Specialization of <a>hliftA</a>.
liftA_NP :: SListI xs => (forall a. f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hliftA</a>.
liftA_POP :: All SListI xss => (forall a. f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hliftA2</a>.
liftA2_NP :: SListI xs => (forall a. f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hliftA2</a>.
liftA2_POP :: All SListI xss => (forall a. f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Specialization of <a>hliftA3</a>.
liftA3_NP :: SListI xs => (forall a. f a -> g a -> h a -> i a) -> NP f xs -> NP g xs -> NP h xs -> NP i xs

-- | Specialization of <a>hliftA3</a>.
liftA3_POP :: All SListI xss => (forall a. f a -> g a -> h a -> i a) -> POP f xss -> POP g xss -> POP h xss -> POP i xss

-- | Specialization of <a>hmap</a>, which is equivalent to <a>hliftA</a>.
map_NP :: SListI xs => (forall a. f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hmap</a>, which is equivalent to <a>hliftA</a>.
map_POP :: All SListI xss => (forall a. f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hzipWith</a>, which is equivalent to
--   <a>hliftA2</a>.
zipWith_NP :: SListI xs => (forall a. f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hzipWith</a>, which is equivalent to
--   <a>hliftA2</a>.
zipWith_POP :: All SListI xss => (forall a. f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Specialization of <a>hzipWith3</a>, which is equivalent to
--   <a>hliftA3</a>.
zipWith3_NP :: SListI xs => (forall a. f a -> g a -> h a -> i a) -> NP f xs -> NP g xs -> NP h xs -> NP i xs

-- | Specialization of <a>hzipWith3</a>, which is equivalent to
--   <a>hliftA3</a>.
zipWith3_POP :: All SListI xss => (forall a. f a -> g a -> h a -> i a) -> POP f xss -> POP g xss -> POP h xss -> POP i xss

-- | Specialization of <a>hcliftA</a>.
cliftA_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hcliftA</a>.
cliftA_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hcliftA2</a>.
cliftA2_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hcliftA2</a>.
cliftA2_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Specialization of <a>hcliftA3</a>.
cliftA3_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a -> h a -> i a) -> NP f xs -> NP g xs -> NP h xs -> NP i xs

-- | Specialization of <a>hcliftA3</a>.
cliftA3_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a -> h a -> i a) -> POP f xss -> POP g xss -> POP h xss -> POP i xss

-- | Specialization of <a>hcmap</a>, which is equivalent to <a>hcliftA</a>.
cmap_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a) -> NP f xs -> NP g xs

-- | Specialization of <a>hcmap</a>, which is equivalent to <a>hcliftA</a>.
cmap_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a) -> POP f xss -> POP g xss

-- | Specialization of <a>hczipWith</a>, which is equivalent to
--   <a>hcliftA2</a>.
czipWith_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a -> h a) -> NP f xs -> NP g xs -> NP h xs

-- | Specialization of <a>hczipWith</a>, which is equivalent to
--   <a>hcliftA2</a>.
czipWith_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a -> h a) -> POP f xss -> POP g xss -> POP h xss

-- | Specialization of <a>hczipWith3</a>, which is equivalent to
--   <a>hcliftA3</a>.
czipWith3_NP :: All c xs => proxy c -> (forall a. c a => f a -> g a -> h a -> i a) -> NP f xs -> NP g xs -> NP h xs -> NP i xs

-- | Specialization of <a>hczipWith3</a>, which is equivalent to
--   <a>hcliftA3</a>.
czipWith3_POP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a -> h a -> i a) -> POP f xss -> POP g xss -> POP h xss -> POP i xss

-- | Lift a constrained function operating on a list-indexed structure to a
--   function on a list-of-list-indexed structure.
--   
--   This is a variant of <a>hcliftA</a>.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA'</a> p f xs = <a>hpure</a> (<a>fn_2</a> $ \ <tt>AllDictC</tt> -&gt; f) ` <a>hap</a> ` <tt>allDict_NP</tt> p ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NP</a> f xss -&gt; <a>NP</a> f' xss
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NS</a> f xss -&gt; <a>NS</a> f' xss
--   </pre>

-- | <i>Deprecated: Use <a>hcliftA</a> or <a>hcmap</a> instead.</i>
hcliftA' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs) -> h f xss -> h f' xss

-- | Like <a>hcliftA'</a>, but for binary functions.

-- | <i>Deprecated: Use <a>hcliftA2</a> or <a>hczipWith</a> instead.</i>
hcliftA2' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs -> f'' xs) -> Prod h f xss -> h f' xss -> h f'' xss

-- | Like <a>hcliftA'</a>, but for ternay functions.

-- | <i>Deprecated: Use <a>hcliftA3</a> or <a>hczipWith3</a> instead.</i>
hcliftA3' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs -> f'' xs -> f''' xs) -> Prod h f xss -> Prod h f' xss -> h f'' xss -> h f''' xss

-- | Specialization of <a>hcliftA2'</a>.

-- | <i>Deprecated: Use <a>cliftA2_NP</a> instead.</i>
cliftA2'_NP :: All2 c xss => proxy c -> (forall xs. All c xs => f xs -> g xs -> h xs) -> NP f xss -> NP g xss -> NP h xss

-- | Specialization of <a>hcollapse</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; collapse_NP (K 1 :* K 2 :* K 3 :* Nil)
--   [1,2,3]
--   </pre>
collapse_NP :: NP (K a) xs -> [a]

-- | Specialization of <a>hcollapse</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; collapse_POP (POP ((K 'a' :* Nil) :* (K 'b' :* K 'c' :* Nil) :* Nil) :: POP (K Char) '[ '[(a :: *)], '[b, c] ])
--   ["a","bc"]
--   </pre>
--   
--   (The type signature is only necessary in this case to fix the kind of
--   the type variables.)
collapse_POP :: SListI xss => POP (K a) xss -> [[a]]

-- | Specialization of <a>hctraverse_</a>.
ctraverse__NP :: forall c proxy xs f g. (All c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g ()) -> NP f xs -> g ()

-- | Specialization of <a>hctraverse_</a>.
ctraverse__POP :: forall c proxy xss f g. (All2 c xss, Applicative g) => proxy c -> (forall a. c a => f a -> g ()) -> POP f xss -> g ()

-- | Specialization of <a>htraverse_</a>.
traverse__NP :: forall xs f g. (SListI xs, Applicative g) => (forall a. f a -> g ()) -> NP f xs -> g ()

-- | Specialization of <a>htraverse_</a>.
traverse__POP :: forall xss f g. (SListI2 xss, Applicative g) => (forall a. f a -> g ()) -> POP f xss -> g ()

-- | Specialization of <a>hcfoldMap</a>.
cfoldMap_NP :: (All c xs, Monoid m) => proxy c -> (forall a. c a => f a -> m) -> NP f xs -> m

-- | Specialization of <a>hcfoldMap</a>.
cfoldMap_POP :: (All2 c xs, Monoid m) => proxy c -> (forall a. c a => f a -> m) -> POP f xs -> m

-- | Specialization of <a>hsequence'</a>.
sequence'_NP :: Applicative f => NP (f :.: g) xs -> f (NP g xs)

-- | Specialization of <a>hsequence'</a>.
sequence'_POP :: (SListI xss, Applicative f) => POP (f :.: g) xss -> f (POP g xss)

-- | Specialization of <a>hsequence</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; sequence_NP (Just 1 :* Just 2 :* Nil)
--   Just (I 1 :* I 2 :* Nil)
--   </pre>
sequence_NP :: (SListI xs, Applicative f) => NP f xs -> f (NP I xs)

-- | Specialization of <a>hsequence</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; sequence_POP (POP ((Just 1 :* Nil) :* (Just 2 :* Just 3 :* Nil) :* Nil))
--   Just (POP ((I 1 :* Nil) :* (I 2 :* I 3 :* Nil) :* Nil))
--   </pre>
sequence_POP :: (All SListI xss, Applicative f) => POP f xss -> f (POP I xss)

-- | Specialization of <a>hctraverse'</a>.
ctraverse'_NP :: forall c proxy xs f f' g. (All c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> NP f xs -> g (NP f' xs)

-- | Specialization of <a>hctraverse'</a>.
ctraverse'_POP :: (All2 c xss, Applicative g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> POP f xss -> g (POP f' xss)

-- | Specialization of <a>htraverse'</a>.
traverse'_NP :: forall xs f f' g. (SListI xs, Applicative g) => (forall a. f a -> g (f' a)) -> NP f xs -> g (NP f' xs)

-- | Specialization of <a>hctraverse'</a>.
traverse'_POP :: (SListI2 xss, Applicative g) => (forall a. f a -> g (f' a)) -> POP f xss -> g (POP f' xss)

-- | Specialization of <a>hctraverse</a>.
ctraverse_NP :: (All c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> NP f xs -> g (NP I xs)

-- | Specialization of <a>hctraverse</a>.
ctraverse_POP :: (All2 c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> POP f xs -> g (POP I xs)

-- | Catamorphism for <a>NP</a>.
--   
--   This is a suitable generalization of <a>foldr</a>. It takes parameters
--   on what to do for <a>Nil</a> and <a>:*</a>. Since the input list is
--   heterogeneous, the result is also indexed by a type-level list.
cata_NP :: forall r f xs. r '[] -> (forall y ys. f y -> r ys -> r (y : ys)) -> NP f xs -> r xs

-- | Constrained catamorphism for <a>NP</a>.
--   
--   The difference compared to <a>cata_NP</a> is that the function for the
--   cons-case can make use of the fact that the specified constraint holds
--   for all the types in the signature of the product.
ccata_NP :: forall c proxy r f xs. (All c xs) => proxy c -> r '[] -> (forall y ys. c y => f y -> r ys -> r (y : ys)) -> NP f xs -> r xs

-- | Anamorphism for <a>NP</a>.
--   
--   In contrast to the anamorphism for normal lists, the generating
--   function does not return an <a>Either</a>, but simply an element and a
--   new seed value.
--   
--   This is because the decision on whether to generate a <a>Nil</a> or a
--   <a>:*</a> is determined by the types.
ana_NP :: forall s f xs. SListI xs => (forall y ys. s (y : ys) -> (f y, s ys)) -> s xs -> NP f xs

-- | Constrained anamorphism for <a>NP</a>.
--   
--   Compared to <a>ana_NP</a>, the generating function can make use of the
--   specified constraint here for the elements that it generates.
cana_NP :: forall c proxy s f xs. (All c xs) => proxy c -> (forall y ys. c y => s (y : ys) -> (f y, s ys)) -> s xs -> NP f xs

-- | Specialization of <a>htrans</a>.
trans_NP :: AllZip c xs ys => proxy c -> (forall x y. c x y => f x -> g y) -> NP f xs -> NP g ys

-- | Specialization of <a>htrans</a>.
trans_POP :: AllZip2 c xss yss => proxy c -> (forall x y. c x y => f x -> g y) -> POP f xss -> POP g yss

-- | Specialization of <a>hcoerce</a>.
coerce_NP :: forall f g xs ys. AllZip (LiftedCoercible f g) xs ys => NP f xs -> NP g ys

-- | Specialization of <a>hcoerce</a>.
coerce_POP :: forall f g xss yss. AllZip2 (LiftedCoercible f g) xss yss => POP f xss -> POP g yss

-- | Specialization of <a>hfromI</a>.
fromI_NP :: forall f xs ys. AllZip (LiftedCoercible I f) xs ys => NP I xs -> NP f ys

-- | Specialization of <a>hfromI</a>.
fromI_POP :: forall f xss yss. AllZip2 (LiftedCoercible I f) xss yss => POP I xss -> POP f yss

-- | Specialization of <a>htoI</a>.
toI_NP :: forall f xs ys. AllZip (LiftedCoercible f I) xs ys => NP f xs -> NP I ys

-- | Specialization of <a>htoI</a>.
toI_POP :: forall f xss yss. AllZip2 (LiftedCoercible f I) xss yss => POP f xss -> POP I yss
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq f) xs => GHC.Classes.Eq (Generics.SOP.NP.NP f xs)
instance forall k (f :: k -> *) (xs :: [k]). (Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Ord f) xs) => GHC.Classes.Ord (Generics.SOP.NP.NP f xs)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Show.Show (Generics.SOP.NP.NP (Generics.SOP.NP.NP f) xss) => GHC.Show.Show (Generics.SOP.NP.POP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Classes.Eq (Generics.SOP.NP.NP (Generics.SOP.NP.NP f) xss) => GHC.Classes.Eq (Generics.SOP.NP.POP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Classes.Ord (Generics.SOP.NP.NP (Generics.SOP.NP.NP f) xss) => GHC.Classes.Ord (Generics.SOP.NP.POP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). Control.DeepSeq.NFData (Generics.SOP.NP.NP (Generics.SOP.NP.NP f) xss) => Control.DeepSeq.NFData (Generics.SOP.NP.POP f xss)
instance Generics.SOP.Classes.HPure Generics.SOP.NP.POP
instance Generics.SOP.Classes.HAp Generics.SOP.NP.POP
instance Generics.SOP.Classes.HCollapse Generics.SOP.NP.POP
instance Generics.SOP.Classes.HTraverse_ Generics.SOP.NP.POP
instance Generics.SOP.Classes.HSequence Generics.SOP.NP.POP
instance Generics.SOP.Classes.HTrans Generics.SOP.NP.POP Generics.SOP.NP.POP
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Show.Show f) xs => GHC.Show.Show (Generics.SOP.NP.NP f xs)
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose Control.DeepSeq.NFData f) xs => Control.DeepSeq.NFData (Generics.SOP.NP.NP f xs)
instance Generics.SOP.Classes.HPure Generics.SOP.NP.NP
instance Generics.SOP.Classes.HAp Generics.SOP.NP.NP
instance Generics.SOP.Classes.HCollapse Generics.SOP.NP.NP
instance Generics.SOP.Classes.HTraverse_ Generics.SOP.NP.NP
instance Generics.SOP.Classes.HSequence Generics.SOP.NP.NP
instance Generics.SOP.Classes.HTrans Generics.SOP.NP.NP Generics.SOP.NP.NP


-- | n-ary sums (and sums of products)
module Generics.SOP.NS

-- | An n-ary sum.
--   
--   The sum is parameterized by a type constructor <tt>f</tt> and indexed
--   by a type-level list <tt>xs</tt>. The length of the list determines
--   the number of choices in the sum and if the <tt>i</tt>-th element of
--   the list is of type <tt>x</tt>, then the <tt>i</tt>-th choice of the
--   sum is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble Peano-style natural
--   numbers, i.e., <a>Z</a> is for "zero", and <a>S</a> is for
--   "successor". Chaining <a>S</a> and <a>Z</a> chooses the corresponding
--   component of the sum.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z         :: f x -&gt; NS f (x ': xs)
--   S . Z     :: f y -&gt; NS f (x ': y ': xs)
--   S . S . Z :: f z -&gt; NS f (x ': y ': z ': xs)
--   ...
--   </pre>
--   
--   Note that empty sums (indexed by an empty list) have no non-bottom
--   elements.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the sum
--   becomes a direct generalization of the <a>Either</a> type to
--   arbitrarily many choices. For <tt><a>K</a> a</tt>, the result is a
--   homogeneous choice type, where the contents of the type-level list are
--   ignored, but its length specifies the number of options.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   sum describes the top-level structure of a datatype, which is a choice
--   between all of its constructors.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z (I 'x')      :: NS I       '[ Char, Bool ]
--   S (Z (I True)) :: NS I       '[ Char, Bool ]
--   S (Z (K 1))    :: NS (K Int) '[ Char, Bool ]
--   </pre>
data NS :: (k -> *) -> [k] -> *
[Z] :: f x -> NS f (x : xs)
[S] :: NS f xs -> NS f (x : xs)

-- | A sum of products.
--   
--   This is a 'newtype' for an <a>NS</a> of an <a>NP</a>. The elements of
--   the (inner) products are applications of the parameter <tt>f</tt>. The
--   type <a>SOP</a> is indexed by the list of lists that determines the
--   sizes of both the (outer) sum and all the (inner) products, as well as
--   the types of all the elements of the inner products.
--   
--   An <tt><a>SOP</a> <a>I</a></tt> reflects the structure of a normal
--   Haskell datatype. The sum structure represents the choice between the
--   different constructors, the product structure represents the arguments
--   of each constructor.
newtype SOP (f :: (k -> *)) (xss :: [[k]])
SOP :: (NS (NP f) xss) -> SOP

-- | Unwrap a sum of products.
unSOP :: SOP f xss -> NS (NP f) xss

-- | The type of injections into an n-ary sum.
--   
--   If you expand the type synonyms and newtypes involved, you get
--   
--   <pre>
--   Injection f xs a = (f -.-&gt; K (NS f xs)) a ~= f a -&gt; K (NS f xs) a ~= f a -&gt; NS f xs
--   </pre>
--   
--   If we pick <tt>a</tt> to be an element of <tt>xs</tt>, this indeed
--   corresponds to an injection into the sum.
type Injection (f :: k -> *) (xs :: [k]) = f -.-> K (NS f xs)

-- | Compute all injections into an n-ary sum.
--   
--   Each element of the resulting product contains one of the injections.
injections :: forall xs f. SListI xs => NP (Injection f xs) xs

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.

-- | <i>Deprecated: Use <a>shiftInjection</a> instead.</i>
shift :: Injection f xs a -> Injection f (x : xs) a

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shiftInjection :: Injection f xs a -> Injection f (x : xs) a

-- | Apply injections to a product.
--   
--   Given a product containing all possible choices, produce a list of
--   sums by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_NP (I 'x' :* I True :* I 2 :* Nil)
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
apInjs_NP :: SListI xs => NP f xs -> [NS f xs]

-- | <a>apInjs_NP</a> without <a>hcollapse</a>.
--   
--   <pre>
--   &gt;&gt;&gt; apInjs'_NP (I 'x' :* I True :* I 2 :* Nil)
--   K (Z (I 'x')) :* K (S (Z (I True))) :* K (S (S (Z (I 2)))) :* Nil
--   </pre>
apInjs'_NP :: SListI xs => NP f xs -> NP (K (NS f xs)) xs

-- | Apply injections to a product of product.
--   
--   This operates on the outer product only. Given a product containing
--   all possible choices (that are products), produce a list of sums (of
--   products) by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
apInjs_POP :: SListI xss => POP f xss -> [SOP f xss]

-- | <a>apInjs_POP</a> without <a>hcollapse</a>.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs'_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   K (SOP (Z (I 'x' :* Nil))) :* K (SOP (S (Z (I True :* I 2 :* Nil)))) :* Nil
--   </pre>
apInjs'_POP :: SListI xss => POP f xss -> NP (K (SOP f xss)) xss

-- | Extract the payload from a unary sum.
--   
--   For larger sums, this function would be partial, so it is only
--   provided with a rather restrictive type.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; unZ (Z (I 'x'))
--   I 'x'
--   </pre>
unZ :: NS f '[x] -> f x

-- | Obtain the index from an n-ary sum.
--   
--   An n-nary sum represents a choice between n different options. This
--   function returns an integer between 0 and n - 1 indicating the option
--   chosen by the given value.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; index_NS (S (S (Z (I False))))
--   2
--   
--   &gt;&gt;&gt; index_NS (Z (K ()))
--   0
--   </pre>
index_NS :: forall f xs. NS f xs -> Int

-- | Obtain the index from an n-ary sum of products.
--   
--   An n-nary sum represents a choice between n different options. This
--   function returns an integer between 0 and n - 1 indicating the option
--   chosen by the given value.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>index_SOP</a> = <a>index_NS</a> <a>.</a> <a>unSOP</a>
--   </pre>
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; index_SOP (SOP (S (Z (I True :* I 'x' :* Nil))))
--   1
--   </pre>
index_SOP :: SOP f xs -> Int

-- | Specialization of <a>hap</a>.
ap_NS :: NP (f -.-> g) xs -> NS f xs -> NS g xs

-- | Specialization of <a>hap</a>.
ap_SOP :: POP (f -.-> g) xss -> SOP f xss -> SOP g xss

-- | Specialization of <a>hliftA</a>.
liftA_NS :: SListI xs => (forall a. f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hliftA</a>.
liftA_SOP :: All SListI xss => (forall a. f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hliftA2</a>.
liftA2_NS :: SListI xs => (forall a. f a -> g a -> h a) -> NP f xs -> NS g xs -> NS h xs

-- | Specialization of <a>hliftA2</a>.
liftA2_SOP :: All SListI xss => (forall a. f a -> g a -> h a) -> POP f xss -> SOP g xss -> SOP h xss

-- | Specialization of <a>hcliftA</a>.
cliftA_NS :: All c xs => proxy c -> (forall a. c a => f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hcliftA</a>.
cliftA_SOP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hcliftA2</a>.
cliftA2_NS :: All c xs => proxy c -> (forall a. c a => f a -> g a -> h a) -> NP f xs -> NS g xs -> NS h xs

-- | Specialization of <a>hcliftA2</a>.
cliftA2_SOP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a -> h a) -> POP f xss -> SOP g xss -> SOP h xss

-- | Specialization of <a>hmap</a>, which is equivalent to <a>hliftA</a>.
map_NS :: SListI xs => (forall a. f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hmap</a>, which is equivalent to <a>hliftA</a>.
map_SOP :: All SListI xss => (forall a. f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hcmap</a>, which is equivalent to <a>hcliftA</a>.
cmap_NS :: All c xs => proxy c -> (forall a. c a => f a -> g a) -> NS f xs -> NS g xs

-- | Specialization of <a>hcmap</a>, which is equivalent to <a>hcliftA</a>.
cmap_SOP :: All2 c xss => proxy c -> (forall a. c a => f a -> g a) -> SOP f xss -> SOP g xss

-- | Specialization of <a>hcliftA2'</a>.

-- | <i>Deprecated: Use <a>cliftA2_NS</a> instead.</i>
cliftA2'_NS :: All2 c xss => proxy c -> (forall xs. All c xs => f xs -> g xs -> h xs) -> NP f xss -> NS g xss -> NS h xss

-- | Compare two sums with respect to the choice they are making.
--   
--   A value that chooses the first option is considered smaller than one
--   that chooses the second option.
--   
--   If the choices are different, then either the first (if the first is
--   smaller than the second) or the third (if the first is larger than the
--   second) argument are called. If both choices are equal, then the
--   second argument is called, which has access to the elements contained
--   in the sums.
compare_NS :: forall r f g xs. r -> (forall x. f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Constrained version of <a>compare_NS</a>.
ccompare_NS :: forall c proxy r f g xs. (All c xs) => proxy c -> r -> (forall x. c x => f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Compare two sums of products with respect to the choice in the sum
--   they are making.
--   
--   Only the sum structure is used for comparison. This is a small wrapper
--   around <a>ccompare_NS</a> for a common special case.
compare_SOP :: forall r f g xss. r -> (forall xs. NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Constrained version of <a>compare_SOP</a>.
ccompare_SOP :: forall c proxy r f g xss. (All2 c xss) => proxy c -> r -> (forall xs. All c xs => NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Specialization of <a>hcollapse</a>.
collapse_NS :: NS (K a) xs -> a

-- | Specialization of <a>hcollapse</a>.
collapse_SOP :: SListI xss => SOP (K a) xss -> [a]

-- | Specialization of <a>hctraverse_</a>.
--   
--   <i>Note:</i> we don't need <a>Applicative</a> constraint.
ctraverse__NS :: forall c proxy xs f g. (All c xs) => proxy c -> (forall a. c a => f a -> g ()) -> NS f xs -> g ()

-- | Specialization of <a>hctraverse_</a>.
ctraverse__SOP :: forall c proxy xss f g. (All2 c xss, Applicative g) => proxy c -> (forall a. c a => f a -> g ()) -> SOP f xss -> g ()

-- | Specialization of <a>htraverse_</a>.
--   
--   <i>Note:</i> we don't need <a>Applicative</a> constraint.
traverse__NS :: forall xs f g. (SListI xs) => (forall a. f a -> g ()) -> NS f xs -> g ()

-- | Specialization of <a>htraverse_</a>.
traverse__SOP :: forall xss f g. (SListI2 xss, Applicative g) => (forall a. f a -> g ()) -> SOP f xss -> g ()

-- | Specialization of <a>hcfoldMap</a>.
--   
--   <i>Note:</i> We don't need <a>Monoid</a> instance.
cfoldMap_NS :: forall c proxy f xs m. (All c xs) => proxy c -> (forall a. c a => f a -> m) -> NS f xs -> m

-- | Specialization of <a>hcfoldMap</a>.
cfoldMap_SOP :: (All2 c xs, Monoid m) => proxy c -> (forall a. c a => f a -> m) -> SOP f xs -> m

-- | Specialization of <a>hsequence'</a>.
sequence'_NS :: Applicative f => NS (f :.: g) xs -> f (NS g xs)

-- | Specialization of <a>hsequence'</a>.
sequence'_SOP :: (SListI xss, Applicative f) => SOP (f :.: g) xss -> f (SOP g xss)

-- | Specialization of <a>hsequence</a>.
sequence_NS :: (SListI xs, Applicative f) => NS f xs -> f (NS I xs)

-- | Specialization of <a>hsequence</a>.
sequence_SOP :: (All SListI xss, Applicative f) => SOP f xss -> f (SOP I xss)

-- | Specialization of <a>hctraverse'</a>.
--   
--   <i>Note:</i> as <a>NS</a> has exactly one element, the <a>Functor</a>
--   constraint is enough.
ctraverse'_NS :: forall c proxy xs f f' g. (All c xs, Functor g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> NS f xs -> g (NS f' xs)

-- | Specialization of <a>hctraverse'</a>.
ctraverse'_SOP :: (All2 c xss, Applicative g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> SOP f xss -> g (SOP f' xss)

-- | Specialization of <a>htraverse'</a>.
--   
--   <i>Note:</i> as <a>NS</a> has exactly one element, the <a>Functor</a>
--   constraint is enough.
traverse'_NS :: forall xs f f' g. (SListI xs, Functor g) => (forall a. f a -> g (f' a)) -> NS f xs -> g (NS f' xs)

-- | Specialization of <a>htraverse'</a>.
traverse'_SOP :: (SListI2 xss, Applicative g) => (forall a. f a -> g (f' a)) -> SOP f xss -> g (SOP f' xss)

-- | Specialization of <a>hctraverse</a>.
ctraverse_NS :: (All c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> NP f xs -> g (NP I xs)

-- | Specialization of <a>hctraverse</a>.
ctraverse_SOP :: (All2 c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> POP f xs -> g (POP I xs)

-- | Catamorphism for <a>NS</a>.
--   
--   Takes arguments determining what to do for <a>Z</a> and what to do for
--   <a>S</a>. The result type is still indexed over the type-level lit.
cata_NS :: forall r f xs. (forall y ys. f y -> r (y : ys)) -> (forall y ys. r ys -> r (y : ys)) -> NS f xs -> r xs

-- | Constrained catamorphism for <a>NS</a>.
ccata_NS :: forall c proxy r f xs. (All c xs) => proxy c -> (forall y ys. c y => f y -> r (y : ys)) -> (forall y ys. c y => r ys -> r (y : ys)) -> NS f xs -> r xs

-- | Anamorphism for <a>NS</a>.
ana_NS :: forall s f xs. (SListI xs) => (forall r. s '[] -> r) -> (forall y ys. s (y : ys) -> Either (f y) (s ys)) -> s xs -> NS f xs

-- | Constrained anamorphism for <a>NS</a>.
cana_NS :: forall c proxy s f xs. (All c xs) => proxy c -> (forall r. s '[] -> r) -> (forall y ys. c y => s (y : ys) -> Either (f y) (s ys)) -> s xs -> NS f xs

-- | Specialization of <a>hexpand</a>.
expand_NS :: forall f xs. (SListI xs) => (forall x. f x) -> NS f xs -> NP f xs

-- | Specialization of <a>hcexpand</a>.
cexpand_NS :: forall c proxy f xs. (All c xs) => proxy c -> (forall x. c x => f x) -> NS f xs -> NP f xs

-- | Specialization of <a>hexpand</a>.
expand_SOP :: forall f xss. (All SListI xss) => (forall x. f x) -> SOP f xss -> POP f xss

-- | Specialization of <a>hcexpand</a>.
cexpand_SOP :: forall c proxy f xss. (All2 c xss) => proxy c -> (forall x. c x => f x) -> SOP f xss -> POP f xss

-- | Specialization of <a>htrans</a>.
trans_NS :: AllZip c xs ys => proxy c -> (forall x y. c x y => f x -> g y) -> NS f xs -> NS g ys

-- | Specialization of <a>htrans</a>.
trans_SOP :: AllZip2 c xss yss => proxy c -> (forall x y. c x y => f x -> g y) -> SOP f xss -> SOP g yss

-- | Specialization of <a>hcoerce</a>.
coerce_NS :: forall f g xs ys. AllZip (LiftedCoercible f g) xs ys => NS f xs -> NS g ys

-- | Specialization of <a>hcoerce</a>.
coerce_SOP :: forall f g xss yss. AllZip2 (LiftedCoercible f g) xss yss => SOP f xss -> SOP g yss

-- | Specialization of <a>hfromI</a>.
fromI_NS :: forall f xs ys. AllZip (LiftedCoercible I f) xs ys => NS I xs -> NS f ys

-- | Specialization of <a>hfromI</a>.
fromI_SOP :: forall f xss yss. AllZip2 (LiftedCoercible I f) xss yss => SOP I xss -> SOP f yss

-- | Specialization of <a>htoI</a>.
toI_NS :: forall f xs ys. AllZip (LiftedCoercible f I) xs ys => NS f xs -> NS I ys

-- | Specialization of <a>htoI</a>.
toI_SOP :: forall f xss yss. AllZip2 (LiftedCoercible f I) xss yss => SOP f xss -> SOP I yss
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Show.Show f) xs => GHC.Show.Show (Generics.SOP.NS.NS f xs)
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq f) xs => GHC.Classes.Eq (Generics.SOP.NS.NS f xs)
instance forall k (f :: k -> *) (xs :: [k]). (Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq f) xs, Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Ord f) xs) => GHC.Classes.Ord (Generics.SOP.NS.NS f xs)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Show.Show (Generics.SOP.NS.NS (Generics.SOP.NP.NP f) xss) => GHC.Show.Show (Generics.SOP.NS.SOP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Classes.Eq (Generics.SOP.NS.NS (Generics.SOP.NP.NP f) xss) => GHC.Classes.Eq (Generics.SOP.NS.SOP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). GHC.Classes.Ord (Generics.SOP.NS.NS (Generics.SOP.NP.NP f) xss) => GHC.Classes.Ord (Generics.SOP.NS.SOP f xss)
instance forall k (f :: k -> *) (xss :: [[k]]). Control.DeepSeq.NFData (Generics.SOP.NS.NS (Generics.SOP.NP.NP f) xss) => Control.DeepSeq.NFData (Generics.SOP.NS.SOP f xss)
instance Generics.SOP.Classes.HIndex Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HApInjs Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HAp Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HCollapse Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HTraverse_ Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HSequence Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HExpand Generics.SOP.NS.SOP
instance Generics.SOP.Classes.HTrans Generics.SOP.NS.SOP Generics.SOP.NS.SOP
instance forall k (f :: k -> *) (xs :: [k]). Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose Control.DeepSeq.NFData f) xs => Control.DeepSeq.NFData (Generics.SOP.NS.NS f xs)
instance Generics.SOP.Classes.HIndex Generics.SOP.NS.NS
instance Generics.SOP.Classes.HApInjs Generics.SOP.NS.NS
instance Generics.SOP.Classes.HAp Generics.SOP.NS.NS
instance Generics.SOP.Classes.HCollapse Generics.SOP.NS.NS
instance Generics.SOP.Classes.HTraverse_ Generics.SOP.NS.NS
instance Generics.SOP.Classes.HSequence Generics.SOP.NS.NS
instance Generics.SOP.Classes.HExpand Generics.SOP.NS.NS
instance Generics.SOP.Classes.HTrans Generics.SOP.NS.NS Generics.SOP.NS.NS


-- | Metadata about what a datatype looks like
--   
--   In <tt>generics-sop</tt>, the metadata is completely independent of
--   the main universe. Many generic functions will use this metadata, but
--   other don't, and yet others might need completely different metadata.
--   
--   This module defines a datatype to represent standard metadata, i.e.,
--   names of the datatype, its constructors, and possibly its record
--   selectors. Metadata descriptions are in general GADTs indexed by the
--   code of the datatype they're associated with, so matching on the
--   metadata will reveal information about the shape of the datatype.
module Generics.SOP.Metadata

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[*]] -> *
[ADT] :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> DatatypeInfo xss
[Newtype] :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '['[x]]

-- | The module name where a datatype is defined.
moduleName :: DatatypeInfo xss -> ModuleName

-- | The name of a datatype (or newtype).
datatypeName :: DatatypeInfo xss -> DatatypeName

-- | The constructor info for a datatype (or newtype).
constructorInfo :: DatatypeInfo xss -> NP ConstructorInfo xss

-- | Metadata for a single constructors.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [*] -> *
[Constructor] :: SListI xs => ConstructorName -> ConstructorInfo xs
[Infix] :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
[Record] :: SListI xs => ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | The name of a constructor.
constructorName :: ConstructorInfo xs -> ConstructorName

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: * -> *
[FieldInfo] :: FieldName -> FieldInfo a

-- | The name of a field.
fieldName :: FieldInfo a -> FieldName

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | The fixity of an infix constructor.
type Fixity = Int

-- | Datatype to represent the associativity of a constructor
data Associativity :: *
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
instance GHC.Base.Functor Generics.SOP.Metadata.FieldInfo
instance GHC.Classes.Ord (Generics.SOP.Metadata.FieldInfo a)
instance GHC.Classes.Eq (Generics.SOP.Metadata.FieldInfo a)
instance GHC.Show.Show (Generics.SOP.Metadata.FieldInfo a)
instance Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Show.Show Generics.SOP.Metadata.ConstructorInfo) xs => GHC.Show.Show (Generics.SOP.Metadata.DatatypeInfo xs)
instance Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.ConstructorInfo) xs => GHC.Classes.Eq (Generics.SOP.Metadata.DatatypeInfo xs)
instance (Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.ConstructorInfo) xs, Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Ord Generics.SOP.Metadata.ConstructorInfo) xs) => GHC.Classes.Ord (Generics.SOP.Metadata.DatatypeInfo xs)
instance Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Show.Show Generics.SOP.Metadata.FieldInfo) xs => GHC.Show.Show (Generics.SOP.Metadata.ConstructorInfo xs)
instance Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.FieldInfo) xs => GHC.Classes.Eq (Generics.SOP.Metadata.ConstructorInfo xs)
instance (Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Eq Generics.SOP.Metadata.FieldInfo) xs, Generics.SOP.Constraint.All (Generics.SOP.Constraint.Compose GHC.Classes.Ord Generics.SOP.Metadata.FieldInfo) xs) => GHC.Classes.Ord (Generics.SOP.Metadata.ConstructorInfo xs)


-- | Explicit dictionaries.
--   
--   When working with compound constraints such as constructed using
--   <a>All</a> or <a>All2</a>, GHC cannot always prove automatically what
--   one would expect to hold.
--   
--   This module provides a way of explicitly proving conversions between
--   such constraints to GHC. Such conversions still have to be manually
--   applied.
--   
--   This module is new and experimental in generics-sop 0.2. It is
--   therefore not yet exported via the main module and has to be imported
--   explicitly. Its interface is to be considered even less stable than
--   that of the rest of the library. Feedback is very welcome though.
module Generics.SOP.Dict

-- | An explicit dictionary carrying evidence of a class constraint.
--   
--   The constraint parameter is separated into a second argument so that
--   <tt><a>Dict</a> c</tt> is of the correct kind to be used directly as a
--   parameter to e.g. <a>NP</a>.
data Dict (c :: k -> Constraint) (a :: k)
[Dict] :: c a => Dict c a

-- | A proof that the trivial constraint holds over all type-level lists.
pureAll :: SListI xs => Dict (All Top) xs

-- | A proof that the trivial constraint holds over all type-level lists of
--   lists.
pureAll2 :: All SListI xss => Dict (All2 Top) xss

-- | Lifts a dictionary conversion over a type-level list.
mapAll :: forall c d xs. (forall a. Dict c a -> Dict d a) -> Dict (All c) xs -> Dict (All d) xs

-- | Lifts a dictionary conversion over a type-level list of lists.
mapAll2 :: forall c d xss. (forall a. Dict c a -> Dict d a) -> Dict (All2 c) xss -> Dict (All2 d) xss

-- | If two constraints <tt>c</tt> and <tt>d</tt> hold over a type-level
--   list <tt>xs</tt>, then the combination of both constraints holds over
--   that list.
zipAll :: Dict (All c) xs -> Dict (All d) xs -> Dict (All (c `And` d)) xs

-- | If two constraints <tt>c</tt> and <tt>d</tt> hold over a type-level
--   list of lists <tt>xss</tt>, then the combination of both constraints
--   holds over that list of lists.
zipAll2 :: All SListI xss => Dict (All2 c) xss -> Dict (All2 d) xss -> Dict (All2 (c `And` d)) xss

-- | If we have a constraint <tt>c</tt> that holds over a type-level list
--   <tt>xs</tt>, we can create a product containing proofs that each
--   individual list element satisfies <tt>c</tt>.
unAll_NP :: forall c xs. Dict (All c) xs -> NP (Dict c) xs

-- | If we have a constraint <tt>c</tt> that holds over a type-level list
--   of lists <tt>xss</tt>, we can create a product of products containing
--   proofs that all the inner elements satisfy <tt>c</tt>.
unAll_POP :: forall c xss. Dict (All2 c) xss -> POP (Dict c) xss

-- | If we have a product containing proofs that each element of
--   <tt>xs</tt> satisfies <tt>c</tt>, then 'All c' holds for <tt>xs</tt>.
all_NP :: NP (Dict c) xs -> Dict (All c) xs

-- | If we have a product of products containing proofs that each inner
--   element of <tt>xss</tt> satisfies <tt>c</tt>, then 'All2 c' holds for
--   <tt>xss</tt>.
all_POP :: SListI xss => POP (Dict c) xss -> Dict (All2 c) xss

-- | The constraint 'All2 c' is convertible to 'All (All c)'.
unAll2 :: Dict (All2 c) xss -> Dict (All (All c)) xss

-- | The constraint 'All (All c)' is convertible to 'All2 c'.
all2 :: Dict (All (All c)) xss -> Dict (All2 c) xss

-- | If we have an explicit dictionary, we can unwrap it and pass a
--   function that makes use of it.
withDict :: Dict c a -> (c a => r) -> r

-- | A structure of dictionaries.
hdicts :: forall h c xs. (AllN h c xs, HPure h) => h (Dict c) xs
instance forall k (c :: k -> GHC.Types.Constraint) (a :: k). GHC.Show.Show (Generics.SOP.Dict.Dict c a)


-- | Type-level metadata
--   
--   This module provides datatypes (to be used promoted) that can
--   represent the metadata of Haskell datatypes on the type level.
--   
--   We do not reuse the term-level metadata types, because these are GADTs
--   that incorporate additional invariants. We could (at least in GHC 8)
--   impose the same invariants on the type level as well, but some tests
--   have revealed that the resulting type are rather inconvenient to work
--   with.
--   
--   So we use simple datatypes to represent the type-level metadata, even
--   if this means that some invariants are not explicitly captured.
--   
--   We establish a relation between the term- and type-level versions of
--   the metadata by automatically computing the term-level version from
--   the type-level version.
--   
--   As we now have two versions of metadata (term-level and type-level)
--   with very similar, yet slightly different datatype definitions, the
--   names between the modules clash, and this module is recommended to be
--   imported qualified when needed.
--   
--   The interface exported by this module is still somewhat experimental.
module Generics.SOP.Type.Metadata

-- | Metadata for a datatype (to be used promoted).
--   
--   A type of kind <tt><a>DatatypeInfo</a></tt> contains meta-information
--   about a datatype that is not contained in its code. This information
--   consists primarily of the names of the datatype, its constructors, and
--   possibly its record selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo

-- | Standard algebraic datatype
ADT :: ModuleName -> DatatypeName -> [ConstructorInfo] -> DatatypeInfo

-- | Newtype
Newtype :: ModuleName -> DatatypeName -> ConstructorInfo -> DatatypeInfo

-- | Metadata for a single constructors (to be used promoted).
data ConstructorInfo

-- | Normal constructor
Constructor :: ConstructorName -> ConstructorInfo

-- | Infix constructor
Infix :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo

-- | Record constructor
Record :: ConstructorName -> [FieldInfo] -> ConstructorInfo

-- | Metadata for a single record field (to be used promoted).
data FieldInfo
FieldInfo :: FieldName -> FieldInfo

-- | The name of a datatype.
type DatatypeName = Symbol

-- | The name of a module.
type ModuleName = Symbol

-- | The name of a data constructor.
type ConstructorName = Symbol

-- | The name of a field / record selector.
type FieldName = Symbol

-- | The fixity of an infix constructor.
type Fixity = Nat

-- | Class for computing term-level datatype information from type-level
--   datatype information.
class DemoteDatatypeInfo (x :: DatatypeInfo) (xss :: [[*]])

-- | Given a proxy of some type-level datatype information, return the
--   corresponding term-level information.
demoteDatatypeInfo :: DemoteDatatypeInfo x xss => proxy x -> DatatypeInfo xss

-- | Class for computing term-level constructor information from type-level
--   constructor information.
class DemoteConstructorInfos (cs :: [ConstructorInfo]) (xss :: [[*]])

-- | Given a proxy of some type-level constructor information, return the
--   corresponding term-level information as a product.
demoteConstructorInfos :: DemoteConstructorInfos cs xss => proxy cs -> NP ConstructorInfo xss

-- | Class for computing term-level constructor information from type-level
--   constructor information.
class DemoteConstructorInfo (x :: ConstructorInfo) (xs :: [*])

-- | Given a proxy of some type-level constructor information, return the
--   corresponding term-level information.
demoteConstructorInfo :: DemoteConstructorInfo x xs => proxy x -> ConstructorInfo xs

-- | Class for computing term-level field information from type-level field
--   information.
class SListI xs => DemoteFieldInfos (fs :: [FieldInfo]) (xs :: [*])

-- | Given a proxy of some type-level field information, return the
--   corresponding term-level information as a product.
demoteFieldInfos :: DemoteFieldInfos fs xs => proxy fs -> NP FieldInfo xs

-- | Class for computing term-level field information from type-level field
--   information.
class DemoteFieldInfo (x :: FieldInfo) (a :: *)

-- | Given a proxy of some type-level field information, return the
--   corresponding term-level information.
demoteFieldInfo :: DemoteFieldInfo x a => proxy x -> FieldInfo a

-- | Class for computing term-level associativity information from
--   type-level associativity information.
class DemoteAssociativity (a :: Associativity)

-- | Given a proxy of some type-level associativity information, return the
--   corresponding term-level information.
demoteAssociativity :: DemoteAssociativity a => proxy a -> Associativity

-- | Datatype to represent the associativity of a constructor
data Associativity :: *
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity
instance (GHC.TypeLits.KnownSymbol s, Generics.SOP.Type.Metadata.DemoteAssociativity a, GHC.TypeNats.KnownNat f) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Infix s a f) '[y, z]
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.LeftAssociative
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.RightAssociative
instance Generics.SOP.Type.Metadata.DemoteAssociativity 'GHC.Generics.NotAssociative
instance (Generics.SOP.Type.Metadata.DemoteFieldInfo f x, Generics.SOP.Type.Metadata.DemoteFieldInfos fs xs) => Generics.SOP.Type.Metadata.DemoteFieldInfos (f : fs) (x : xs)
instance GHC.TypeLits.KnownSymbol s => Generics.SOP.Type.Metadata.DemoteFieldInfo ('Generics.SOP.Type.Metadata.FieldInfo s) a
instance (GHC.TypeLits.KnownSymbol s, Generics.SOP.Type.Metadata.DemoteFieldInfos fs xs) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Record s fs) xs
instance Generics.SOP.Type.Metadata.DemoteFieldInfos '[] '[]
instance (GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol d, Generics.SOP.Type.Metadata.DemoteConstructorInfo c '[x]) => Generics.SOP.Type.Metadata.DemoteDatatypeInfo ('Generics.SOP.Type.Metadata.Newtype m d c) '['[x]]
instance (Generics.SOP.Type.Metadata.DemoteConstructorInfo c xs, Generics.SOP.Type.Metadata.DemoteConstructorInfos cs xss) => Generics.SOP.Type.Metadata.DemoteConstructorInfos (c : cs) (xs : xss)
instance (GHC.TypeLits.KnownSymbol s, Generics.SOP.Sing.SListI xs) => Generics.SOP.Type.Metadata.DemoteConstructorInfo ('Generics.SOP.Type.Metadata.Constructor s) xs
instance (GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol d, Generics.SOP.Type.Metadata.DemoteConstructorInfos cs xss) => Generics.SOP.Type.Metadata.DemoteDatatypeInfo ('Generics.SOP.Type.Metadata.ADT m d cs) xss
instance Generics.SOP.Type.Metadata.DemoteConstructorInfos '[] '[]


-- | Derive <tt>generics-sop</tt> boilerplate instances from GHC's
--   <a>Generic</a>.
--   
--   The technique being used here is described in the following paper:
--   
--   <ul>
--   <li>JosÃ© Pedro MagalhÃ£es and Andres LÃ¶h. <a>Generic Generic
--   Programming</a>. Practical Aspects of Declarative Languages (PADL)
--   2014.</li>
--   </ul>
module Generics.SOP.GGP

-- | Compute the SOP code of a datatype.
--   
--   This requires that <a>Rep</a> is defined, which in turn requires that
--   the type has a <a>Generic</a> (from module <a>GHC.Generics</a>)
--   instance.
--   
--   This is the default definition for <a>Code</a>. For more info, see
--   <a>Generic</a>.
type GCode (a :: *) = ToSumCode (Rep a) '[]

-- | Constraint for the class that computes <a>gfrom</a>.
type GFrom a = GSumFrom (Rep a)

-- | Constraint for the class that computes <a>gto</a>.
type GTo a = GSumTo (Rep a)

-- | Constraint for the class that computes <a>gdatatypeInfo</a>.
type GDatatypeInfo a = DemoteDatatypeInfo (GDatatypeInfoOf a) (GCode a)

-- | Compute the datatype info of a datatype.
type GDatatypeInfoOf (a :: *) = ToInfo (Rep a)

-- | An automatically computed version of <a>from</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>from</a>. For more info, see
--   <a>Generic</a>.
gfrom :: (GFrom a, Generic a) => a -> SOP I (GCode a)

-- | An automatically computed version of <a>to</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>to</a>. For more info, see
--   <a>Generic</a>.
gto :: forall a. (GTo a, Generic a) => SOP I (GCode a) -> a

-- | An automatically computed version of <a>datatypeInfo</a>.
--   
--   This requires that the type being converted has a <a>Generic</a> (from
--   module <a>GHC.Generics</a>) instance.
--   
--   This is the default definition for <a>datatypeInfo</a>. For more info,
--   see <a>HasDatatypeInfo</a>.
gdatatypeInfo :: forall proxy a. (GDatatypeInfo a) => proxy a -> DatatypeInfo (GCode a)
instance (Generics.SOP.GGP.GSumTo a, Generics.SOP.GGP.GSumTo b) => Generics.SOP.GGP.GSumTo (a GHC.Generics.:+: b)
instance Generics.SOP.GGP.GProductTo a => Generics.SOP.GGP.GSumTo (GHC.Generics.M1 GHC.Generics.C c a)
instance Generics.SOP.GGP.GSumTo a => Generics.SOP.GGP.GSumTo (GHC.Generics.M1 GHC.Generics.D c a)
instance (Generics.SOP.GGP.GSumFrom a, Generics.SOP.GGP.GSumFrom b) => Generics.SOP.GGP.GSumFrom (a GHC.Generics.:+: b)
instance Generics.SOP.GGP.GSumFrom a => Generics.SOP.GGP.GSumFrom (GHC.Generics.M1 GHC.Generics.D c a)
instance Generics.SOP.GGP.GProductFrom a => Generics.SOP.GGP.GSumFrom (GHC.Generics.M1 GHC.Generics.C c a)
instance (Generics.SOP.GGP.GProductTo a, Generics.SOP.GGP.GProductTo b) => Generics.SOP.GGP.GProductTo (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GSingleTo a => Generics.SOP.GGP.GProductTo (GHC.Generics.M1 GHC.Generics.S c a)
instance Generics.SOP.GGP.GProductTo GHC.Generics.U1
instance Generics.SOP.GGP.GSingleTo (GHC.Generics.K1 i a)
instance (Generics.SOP.GGP.GProductFrom a, Generics.SOP.GGP.GProductFrom b) => Generics.SOP.GGP.GProductFrom (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GProductFrom GHC.Generics.U1
instance Generics.SOP.GGP.GSingleFrom a => Generics.SOP.GGP.GProductFrom (GHC.Generics.M1 GHC.Generics.S c a)
instance Generics.SOP.GGP.GSingleFrom (GHC.Generics.K1 i a)
instance (Generics.SOP.GGP.GFieldInfos a, Generics.SOP.GGP.GFieldInfos b) => Generics.SOP.GGP.GFieldInfos (a GHC.Generics.:*: b)
instance Generics.SOP.GGP.GFieldInfos GHC.Generics.U1
instance GHC.Generics.Selector c => Generics.SOP.GGP.GFieldInfos (GHC.Generics.M1 GHC.Generics.S c a)


-- | Codes and interpretations
module Generics.SOP.Universe

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of are datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (All SListI (Code a)) => Generic (a :: *) where {
    type family Code a :: [[*]];
    type Code a = GCode a;
}

-- | Converts from a value to its structural representation.
from :: Generic a => a -> Rep a

-- | Converts from a value to its structural representation.
from :: (Generic a, GFrom a, Generic a, Rep a ~ SOP I (GCode a)) => a -> Rep a

-- | Converts from a structural representation back to the original value.
to :: Generic a => Rep a -> a

-- | Converts from a structural representation back to the original value.
to :: (Generic a, GTo a, Generic a, Rep a ~ SOP I (GCode a)) => Rep a -> a

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class HasDatatypeInfo a where {
    type family DatatypeInfoOf a :: DatatypeInfo;
    type DatatypeInfoOf a = GDatatypeInfoOf a;
}

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: HasDatatypeInfo a => proxy a -> DatatypeInfo (Code a)

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: (HasDatatypeInfo a, GDatatypeInfo a, GCode a ~ Code a) => proxy a -> DatatypeInfo (Code a)

-- | Constraint that captures that a datatype is a product type, i.e., a
--   type with a single constructor.
--   
--   It also gives access to the code for the arguments of that
--   constructor.
type IsProductType (a :: *) (xs :: [*]) = (Generic a, Code a ~ '[xs])

-- | Constraint that captures that a datatype is an enumeration type, i.e.,
--   none of the constructors have any arguments.
type IsEnumType (a :: *) = (Generic a, All ((~) '[]) (Code a))

-- | Constraint that captures that a datatype is a single-constructor,
--   single-field datatype. This always holds for newtype-defined types,
--   but it can also be true for data-defined types.
--   
--   The constraint also gives access to the type that is wrapped.
type IsWrappedType (a :: *) (x :: *) = (Generic a, Code a ~ '['[x]])

-- | Constraint that captures that a datatype is a newtype. This makes use
--   of the fact that newtypes are always coercible to the type they wrap,
--   whereas datatypes are not.
type IsNewtype (a :: *) (x :: *) = (IsWrappedType a x, Coercible a x)


-- | Generate <tt>generics-sop</tt> boilerplate instances using Template
--   Haskell.
module Generics.SOP.TH

-- | Generate <tt>generics-sop</tt> boilerplate for the given datatype.
--   
--   This function takes the name of a datatype and generates:
--   
--   <ul>
--   <li>a <a>Code</a> instance</li>
--   <li>a <a>Generic</a> instance</li>
--   <li>a <a>HasDatatypeInfo</a> instance</li>
--   </ul>
--   
--   Note that the generated code will require the <tt>TypeFamilies</tt>
--   and <tt>DataKinds</tt> extensions to be enabled for the module.
--   
--   <i>Example:</i> If you have the datatype
--   
--   <pre>
--   data Tree = Leaf Int | Node Tree Tree
--   </pre>
--   
--   and say
--   
--   <pre>
--   deriveGeneric ''Tree
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   instance Generic Tree where
--   
--     type Code Tree = '[ '[Int], '[Tree, Tree] ]
--   
--     from (Leaf x)   = SOP (   Z (I x :* Nil))
--     from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
--   
--     to (SOP    (Z (I x :* Nil)))         = Leaf x
--     to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
--     to _ = error "unreachable" -- to avoid GHC warnings
--   
--   instance HasDatatypeInfo Tree where
--     type DatatypeInfoOf Tree =
--       T.ADT "Main" "Tree"
--         '[ T.Constructor "Leaf", T.Constructor "Node" ]
--   
--     datatypeInfo _ =
--       T.demoteDatatypeInfo (Proxy :: Proxy (DatatypeInfoOf Tree))
--   </pre>
--   
--   <i>Limitations:</i> Generation does not work for GADTs, for datatypes
--   that involve existential quantification, for datatypes with unboxed
--   fields.
deriveGeneric :: Name -> Q [Dec]

-- | Like <a>deriveGeneric</a>, but omit the <a>HasDatatypeInfo</a>
--   instance.
deriveGenericOnly :: Name -> Q [Dec]

-- | Like <a>deriveGenericOnly</a>, but don't derive class instance, only
--   functions.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveGenericFunctions ''Tree "TreeCode" "fromTree" "toTree"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   type TreeCode = '[ '[Int], '[Tree, Tree] ]
--   
--   fromTree :: Tree -&gt; SOP I TreeCode
--   fromTree (Leaf x)   = SOP (   Z (I x :* Nil))
--   fromTree (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
--   
--   toTree :: SOP I TreeCode -&gt; Tree
--   toTree (SOP    (Z (I x :* Nil)))         = Leaf x
--   toTree (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
--   toTree _ = error "unreachable" -- to avoid GHC warnings
--   </pre>
deriveGenericFunctions :: Name -> String -> String -> String -> Q [Dec]

-- | Derive <tt>DatatypeInfo</tt> value for the type.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveMetadataValue ''Tree "TreeCode" "treeDatatypeInfo"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   treeDatatypeInfo :: DatatypeInfo TreeCode
--   treeDatatypeInfo = ADT "Main" "Tree"
--       (Constructor "Leaf" :* Constructor "Node" :* Nil)
--   </pre>
--   
--   <i>Note:</i> CodeType needs to be derived with
--   <a>deriveGenericFunctions</a>.

-- | <i>Deprecated: Use <a>deriveMetadataType</a> and
--   <tt>demoteDatatypeInfo</tt> instead.</i>
deriveMetadataValue :: Name -> String -> String -> Q [Dec]

-- | Derive <tt>DatatypeInfo</tt> type for the type.
--   
--   <i>Example:</i> If you say
--   
--   <pre>
--   deriveMetadataType ''Tree "TreeDatatypeInfo"
--   </pre>
--   
--   then you get code that is equivalent to:
--   
--   <pre>
--   type TreeDatatypeInfo =
--     T.ADT "Main" "Tree"
--       [ T.Constructor "Leaf", T.Constructor "Node" ]
--   </pre>
deriveMetadataType :: Name -> String -> Q [Dec]


-- | Instances for <tt>Generic</tt> and <tt>HasMetadata</tt>.
--   
--   We define instances for datatypes from <tt>generics-sop</tt> and
--   <tt>base</tt> that are supported.
--   
--   (There are only instances defined in this module, so the documentation
--   is empty.)
module Generics.SOP.Instances
instance Generics.SOP.Universe.Generic Text.Read.Lex.Number
instance Generics.SOP.Universe.HasDatatypeInfo Text.Read.Lex.Number
instance Generics.SOP.Universe.Generic Text.Read.Lex.Lexeme
instance Generics.SOP.Universe.HasDatatypeInfo Text.Read.Lex.Lexeme
instance Generics.SOP.Universe.Generic Text.Printf.FormatParse
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatParse
instance Generics.SOP.Universe.Generic Text.Printf.FormatSign
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatSign
instance Generics.SOP.Universe.Generic Text.Printf.FormatAdjustment
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FormatAdjustment
instance Generics.SOP.Universe.Generic Text.Printf.FieldFormat
instance Generics.SOP.Universe.HasDatatypeInfo Text.Printf.FieldFormat
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.NewlineMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.NewlineMode
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.Newline
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.Newline
instance Generics.SOP.Universe.Generic GHC.IO.Device.SeekMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Device.SeekMode
instance Generics.SOP.Universe.Generic GHC.IO.Handle.Types.BufferMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Handle.Types.BufferMode
instance Generics.SOP.Universe.Generic GHC.IO.IOMode.IOMode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.IOMode.IOMode
instance Generics.SOP.Universe.Generic GHC.IO.Exception.ExitCode
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.ExitCode
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.ArgDescr a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.ArgDescr a)
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.OptDescr a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.OptDescr a)
instance Generics.SOP.Universe.Generic (System.Console.GetOpt.ArgOrder a)
instance Generics.SOP.Universe.HasDatatypeInfo (System.Console.GetOpt.ArgOrder a)
instance Generics.SOP.Universe.Generic Foreign.C.Types.CDouble
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CDouble
instance Generics.SOP.Universe.Generic Foreign.C.Types.CFloat
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CFloat
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSUSeconds
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSUSeconds
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUSeconds
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUSeconds
instance Generics.SOP.Universe.Generic Foreign.C.Types.CTime
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CTime
instance Generics.SOP.Universe.Generic Foreign.C.Types.CClock
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CClock
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUIntMax
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUIntMax
instance Generics.SOP.Universe.Generic Foreign.C.Types.CIntMax
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CIntMax
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUIntPtr
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUIntPtr
instance Generics.SOP.Universe.Generic Foreign.C.Types.CIntPtr
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CIntPtr
instance Generics.SOP.Universe.Generic Foreign.C.Types.CULLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CULLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CLLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CLLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSigAtomic
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSigAtomic
instance Generics.SOP.Universe.Generic Foreign.C.Types.CWchar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CWchar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSize
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSize
instance Generics.SOP.Universe.Generic Foreign.C.Types.CPtrdiff
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CPtrdiff
instance Generics.SOP.Universe.Generic Foreign.C.Types.CULong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CULong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CLong
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CLong
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUInt
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUInt
instance Generics.SOP.Universe.Generic Foreign.C.Types.CInt
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CInt
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUShort
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUShort
instance Generics.SOP.Universe.Generic Foreign.C.Types.CShort
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CShort
instance Generics.SOP.Universe.Generic Foreign.C.Types.CUChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CUChar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CSChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CSChar
instance Generics.SOP.Universe.Generic Foreign.C.Types.CChar
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Types.CChar
instance Generics.SOP.Universe.Generic Foreign.C.Error.Errno
instance Generics.SOP.Universe.HasDatatypeInfo Foreign.C.Error.Errno
instance Generics.SOP.Universe.Generic Data.Version.Version
instance Generics.SOP.Universe.HasDatatypeInfo Data.Version.Version
instance Generics.SOP.Universe.Generic (Data.Proxy.Proxy t)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Proxy.Proxy t)
instance Generics.SOP.Universe.Generic (Data.Ord.Down a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Ord.Down a)
instance Generics.SOP.Universe.Generic (Data.Monoid.Last a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Last a)
instance Generics.SOP.Universe.Generic (Data.Monoid.First a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.First a)
instance Generics.SOP.Universe.Generic (Data.Monoid.Product a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Product a)
instance Generics.SOP.Universe.Generic (Data.Monoid.Sum a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Sum a)
instance Generics.SOP.Universe.Generic Data.Monoid.Any
instance Generics.SOP.Universe.HasDatatypeInfo Data.Monoid.Any
instance Generics.SOP.Universe.Generic Data.Monoid.All
instance Generics.SOP.Universe.HasDatatypeInfo Data.Monoid.All
instance Generics.SOP.Universe.Generic (Data.Monoid.Endo a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Endo a)
instance Generics.SOP.Universe.Generic (Data.Monoid.Dual a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Monoid.Dual a)
instance Generics.SOP.Universe.Generic (Data.Fixed.Fixed a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Fixed.Fixed a)
instance Generics.SOP.Universe.Generic Data.Data.ConstrRep
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.ConstrRep
instance Generics.SOP.Universe.Generic Data.Data.Fixity
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.Fixity
instance Generics.SOP.Universe.Generic Data.Data.DataRep
instance Generics.SOP.Universe.HasDatatypeInfo Data.Data.DataRep
instance Generics.SOP.Universe.Generic (Data.Complex.Complex a)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Complex.Complex a)
instance Generics.SOP.Universe.Generic GHC.Unicode.GeneralCategory
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Unicode.GeneralCategory
instance Generics.SOP.Universe.Generic GHC.IO.MaskingState
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.MaskingState
instance Generics.SOP.Universe.Generic GHC.Exception.ErrorCall
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Exception.ErrorCall
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecUpdError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecUpdError
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecSelError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecSelError
instance Generics.SOP.Universe.Generic Control.Exception.Base.RecConError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.RecConError
instance Generics.SOP.Universe.Generic Control.Exception.Base.PatternMatchFail
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.PatternMatchFail
instance Generics.SOP.Universe.Generic Control.Exception.Base.NoMethodError
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NoMethodError
instance Generics.SOP.Universe.Generic GHC.IO.Exception.Deadlock
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.Deadlock
instance Generics.SOP.Universe.Generic GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.BlockedIndefinitelyOnSTM
instance Generics.SOP.Universe.Generic GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.BlockedIndefinitelyOnMVar
instance Generics.SOP.Universe.Generic Control.Exception.Base.NestedAtomically
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NestedAtomically
instance Generics.SOP.Universe.Generic Control.Exception.Base.NonTermination
instance Generics.SOP.Universe.HasDatatypeInfo Control.Exception.Base.NonTermination
instance Generics.SOP.Universe.Generic GHC.IO.Exception.AsyncException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.AsyncException
instance Generics.SOP.Universe.Generic GHC.IO.Exception.AssertionFailed
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.AssertionFailed
instance Generics.SOP.Universe.Generic GHC.IO.Exception.ArrayException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.ArrayException
instance Generics.SOP.Universe.Generic GHC.Exception.ArithException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Exception.ArithException
instance Generics.SOP.Universe.Generic GHC.IO.Exception.IOException
instance Generics.SOP.Universe.HasDatatypeInfo GHC.IO.Exception.IOException
instance Generics.SOP.Universe.Generic [a]
instance Generics.SOP.Universe.HasDatatypeInfo [a]
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28, t29)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27, t28)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26, t27)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t26)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k, l)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k, l)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j, k)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j, k)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i, j)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i, j)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h, i)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h, i)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g, h)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g, h)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f, g)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f, g)
instance Generics.SOP.Universe.Generic (a, b, c, d, e, f)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e, f)
instance Generics.SOP.Universe.Generic (a, b, c, d, e)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d, e)
instance Generics.SOP.Universe.Generic (a, b, c, d)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c, d)
instance Generics.SOP.Universe.Generic (a, b, c)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b, c)
instance Generics.SOP.Universe.Generic (a, b)
instance Generics.SOP.Universe.HasDatatypeInfo (a, b)
instance Generics.SOP.Universe.Generic ()
instance Generics.SOP.Universe.HasDatatypeInfo ()
instance Generics.SOP.Universe.Generic (Data.Either.Either a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Data.Either.Either a b)
instance Generics.SOP.Universe.Generic (GHC.Base.Maybe a)
instance Generics.SOP.Universe.HasDatatypeInfo (GHC.Base.Maybe a)
instance Generics.SOP.Universe.Generic GHC.Types.Ordering
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.Ordering
instance Generics.SOP.Universe.Generic GHC.Types.Bool
instance Generics.SOP.Universe.HasDatatypeInfo GHC.Types.Bool
instance Generics.SOP.Universe.Generic ((Generics.SOP.BasicFunctors.:.:) f g p)
instance Generics.SOP.Universe.HasDatatypeInfo ((Generics.SOP.BasicFunctors.:.:) f g p)
instance Generics.SOP.Universe.Generic (Generics.SOP.BasicFunctors.K a b)
instance Generics.SOP.Universe.HasDatatypeInfo (Generics.SOP.BasicFunctors.K a b)
instance Generics.SOP.Universe.Generic (Generics.SOP.BasicFunctors.I a)
instance Generics.SOP.Universe.HasDatatypeInfo (Generics.SOP.BasicFunctors.I a)


-- | Main module of <tt>generics-sop</tt>
--   
--   In most cases, you will probably want to import just this module, and
--   possibly <a>Generics.SOP.TH</a> if you want to use Template Haskell to
--   generate <a>Generic</a> instances for you.
--   
--   <h1>Generic programming with sums of products</h1>
--   
--   You need this library if you want to define your own generic functions
--   in the sum-of-products SOP style. Generic programming in the SOP style
--   follows the following idea:
--   
--   <ol>
--   <li>A large class of datatypes can be viewed in a uniform, structured
--   way: the choice between constructors is represented using an n-ary sum
--   (called <a>NS</a>), and the arguments of each constructor are
--   represented using an n-ary product (called <a>NP</a>).</li>
--   <li>The library captures the notion of a datatype being representable
--   in the following way. There is a class <a>Generic</a>, which for a
--   given datatype <tt>A</tt>, associates the isomorphic SOP
--   representation with the original type under the name <tt><a>Rep</a>
--   A</tt>. The class also provides functions <a>from</a> and <a>to</a>
--   that convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> and witness
--   the isomorphism.</li>
--   <li>Since all <a>Rep</a> types are sums of products, you can define
--   functions over them by performing induction on the structure, of by
--   using predefined combinators that the library provides. Such functions
--   then work for all <a>Rep</a> types.</li>
--   <li>By combining the conversion functions <a>from</a> and <a>to</a>
--   with the function that works on <a>Rep</a> types, we obtain a function
--   that works on all types that are in the <a>Generic</a> class.</li>
--   <li>Most types can very easily be made an instance of <a>Generic</a>.
--   For example, if the datatype can be represented using GHC's built-in
--   approach to generic programming and has an instance for the
--   <a>Generic</a> class from module <a>GHC.Generics</a>, then an instance
--   of the SOP <a>Generic</a> can automatically be derived. There is also
--   Template Haskell code in <a>Generics.SOP.TH</a> that allows to
--   auto-generate an instance of <a>Generic</a> for most types.</li>
--   </ol>
--   
--   <h1>Example</h1>
--   
--   <h2>Instantiating a datatype for use with SOP generics</h2>
--   
--   Let's assume we have the datatypes:
--   
--   <pre>
--   data A   = C Bool | D A Int | E (B ())
--   data B a = F | G a Char Bool
--   </pre>
--   
--   To create <a>Generic</a> instances for <tt>A</tt> and <tt>B</tt> via
--   <a>GHC.Generics</a>, we say
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import qualified GHC.Generics as GHC
--   import Generics.SOP
--   
--   data A   = C Bool | D A Int | E (B ())
--     deriving (Show, GHC.Generic)
--   data B a = F | G a Char Bool
--     deriving (Show, GHC.Generic)
--   
--   instance Generic A     -- empty
--   instance Generic (B a) -- empty
--   </pre>
--   
--   Now we can convert between <tt>A</tt> and <tt><a>Rep</a> A</tt> (and
--   between <tt>B</tt> and <tt><a>Rep</a> B</tt>). For example,
--   
--   <pre>
--   &gt;&gt;&gt; from (D (C True) 3) :: Rep A
--   SOP (S (Z (I (C True) :* I 3 :* Nil)))
--   
--   &gt;&gt;&gt; to it :: A
--   D (C True) 3
--   </pre>
--   
--   Note that the transformation is shallow: In <tt>D (C True) 3</tt>, the
--   inner value <tt>C True</tt> of type <tt>A</tt> is not affected by the
--   transformation.
--   
--   For more details about <tt><a>Rep</a> A</tt>, have a look at the
--   <a>Generics.SOP.Universe</a> module.
--   
--   <h2>Defining a generic function</h2>
--   
--   As an example of a generic function, let us define a generic version
--   of <a>rnf</a> from the <tt>deepseq</tt> package.
--   
--   The type of <a>rnf</a> is
--   
--   <pre>
--   NFData a =&gt; a -&gt; ()
--   </pre>
--   
--   and the idea is that for a term <tt>x</tt> of type <tt>a</tt> in the
--   <a>NFData</a> class, <tt>rnf x</tt> forces complete evaluation of
--   <tt>x</tt> (i.e., evaluation to <i>normal form</i>), and returns
--   <tt>()</tt>.
--   
--   We call the generic version of this function <tt>grnf</tt>. A direct
--   definition in SOP style, making use of structural recursion on the
--   sums and products, looks as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf x = grnfS (<a>from</a> x)
--   
--   grnfS :: (<a>All2</a> NFData xss) =&gt; <a>SOP</a> <a>I</a> xss -&gt; ()
--   grnfS (<a>SOP</a> (<a>Z</a> xs))  = grnfP xs
--   grnfS (<a>SOP</a> (<a>S</a> xss)) = grnfS (<a>SOP</a> xss)
--   
--   grnfP :: (<a>All</a> NFData xs) =&gt; <a>NP</a> <a>I</a> xs -&gt; ()
--   grnfP <a>Nil</a>         = ()
--   grnfP (<a>I</a> x <a>:*</a> xs) = x `deepseq` (grnfP xs)
--   </pre>
--   
--   The <tt>grnf</tt> function performs the conversion between <tt>a</tt>
--   and <tt><a>Rep</a> a</tt> by applying <a>from</a> and then applies
--   <tt>grnfS</tt>. The type of <tt>grnf</tt> indicates that <tt>a</tt>
--   must be in the <a>Generic</a> class so that we can apply <a>from</a>,
--   and that all the components of <tt>a</tt> (i.e., all the types that
--   occur as constructor arguments) must be in the <tt>NFData</tt> class
--   (<a>All2</a>).
--   
--   The function <tt>grnfS</tt> traverses the outer sum structure of the
--   sum of products (note that <tt><a>Rep</a> a = <a>SOP</a> <a>I</a>
--   (<a>Code</a> a)</tt>). It encodes which constructor was used to
--   construct the original argument of type <tt>a</tt>. Once we've found
--   the constructor in question (<a>Z</a>), we traverse the arguments of
--   that constructor using <tt>grnfP</tt>.
--   
--   The function <tt>grnfP</tt> traverses the product structure of the
--   constructor arguments. Each argument is evaluated using the
--   <a>deepseq</a> function from the <a>NFData</a> class. This requires
--   that all components of the product must be in the <tt>NFData</tt>
--   class (<a>All</a>) and triggers the corresponding constraints on the
--   other functions. Once the end of the product is reached (<a>Nil</a>),
--   we return <tt>()</tt>.
--   
--   <h2>Defining a generic function using combinators</h2>
--   
--   In many cases, generic functions can be written in a much more concise
--   way by avoiding the explicit structural recursion and resorting to the
--   powerful combinators provided by this library instead.
--   
--   For example, the <tt>grnf</tt> function can also be defined as a
--   one-liner as follows:
--   
--   <pre>
--   grnf :: (<a>Generic</a> a, <a>All2</a> NFData (<a>Code</a> a)) =&gt; a -&gt; ()
--   grnf = <tt>rnf</tt> . <a>hcollapse</a> . <a>hcmap</a> (<a>Proxy</a> :: <a>Proxy</a> NFData) (<a>mapIK</a> rnf) . <a>from</a>
--   </pre>
--   
--   <a>mapIK</a> and friends (<a>mapII</a>, <a>mapKI</a>, etc.) are small
--   helpers for working with <a>I</a> and <a>K</a> functors, for example
--   <a>mapIK</a> is defined as <tt><a>mapIK</a> f = \ (<a>I</a> x) -&gt;
--   <a>K</a> (f x)</tt>
--   
--   The following interaction should provide an idea of the individual
--   transformation steps:
--   
--   <pre>
--   &gt;&gt;&gt; let x = G 2.5 'A' False :: B Double
--   
--   &gt;&gt;&gt; from x
--   SOP (S (Z (I 2.5 :* I 'A' :* I False :* Nil)))
--   
--   &gt;&gt;&gt; hcmap (Proxy :: Proxy NFData) (mapIK rnf) it
--   SOP (S (Z (K () :* K () :* K () :* Nil)))
--   
--   &gt;&gt;&gt; hcollapse it
--   [(),(),()]
--   
--   &gt;&gt;&gt; rnf it
--   ()
--   </pre>
--   
--   The <a>from</a> call converts into the structural representation. Via
--   <a>hcmap</a>, we apply <tt>rnf</tt> to all the components. The result
--   is a sum of products of the same shape, but the components are no
--   longer heterogeneous (<a>I</a>), but homogeneous (<tt><a>K</a>
--   ()</tt>). A homogeneous structure can be collapsed (<a>hcollapse</a>)
--   into a normal Haskell list. Finally, <tt>rnf</tt> actually forces
--   evaluation of this list (and thereby actually drives the evaluation of
--   all the previous steps) and produces the final result.
--   
--   <h2>Using a generic function</h2>
--   
--   We can directly invoke <tt>grnf</tt> on any type that is an instance
--   of class <a>Generic</a>.
--   
--   <pre>
--   &gt;&gt;&gt; grnf (G 2.5 'A' False)
--   ()
--   
--   &gt;&gt;&gt; grnf (G 2.5 undefined False)
--   *** Exception: Prelude.undefined
--   ...
--   </pre>
--   
--   Note that the type of <tt>grnf</tt> requires that all components of
--   the type are in the <a>NFData</a> class. For a recursive datatype such
--   as <tt>B</tt>, this means that we have to make <tt>A</tt> (and in this
--   case, also <tt>B</tt>) an instance of <a>NFData</a> in order to be
--   able to use the <tt>grnf</tt> function. But we can use <tt>grnf</tt>
--   to supply the instance definitions:
--   
--   <pre>
--   instance NFData A where rnf = grnf
--   instance NFData a =&gt; NFData (B a) where rnf = grnf
--   </pre>
--   
--   <h1>More examples</h1>
--   
--   The best way to learn about how to define generic functions in the SOP
--   style is to look at a few simple examples. Examples are provided by
--   the following packages:
--   
--   <ul>
--   <li><tt><a>basic-sop</a></tt> basic examples,</li>
--   <li><tt><a>pretty-sop</a></tt> generic pretty printing,</li>
--   <li><tt><a>lens-sop</a></tt> generically computed lenses,</li>
--   <li><tt><a>json-sop</a></tt> generic JSON conversions.</li>
--   </ul>
--   
--   The generic functions in these packages use a wide variety of the
--   combinators that are offered by the library.
--   
--   <h1>Paper</h1>
--   
--   A detailed description of the ideas behind this library is provided by
--   the paper:
--   
--   <ul>
--   <li>Edsko de Vries and Andres LÃ¶h. <a>True Sums of Products</a>.
--   Workshop on Generic Programming (WGP) 2014.</li>
--   </ul>
module Generics.SOP

-- | The class of representable datatypes.
--   
--   The SOP approach to generic programming is based on viewing datatypes
--   as a representation (<a>Rep</a>) built from the sum of products of its
--   components. The components of are datatype are specified using the
--   <a>Code</a> type family.
--   
--   The isomorphism between the original Haskell datatype and its
--   representation is witnessed by the methods of this class, <a>from</a>
--   and <a>to</a>. So for instances of this class, the following laws
--   should (in general) hold:
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   <a>from</a> <a>.</a> <a>to</a> === <a>id</a> :: <a>Rep</a> a -&gt; <a>Rep</a> a
--   </pre>
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically.
--   
--   <i>Option 1:</i> Derive via the built-in GHC-generics. For this, you
--   need to use the <tt>DeriveGeneric</tt> extension to first derive an
--   instance of the <a>Generic</a> class from module <a>GHC.Generics</a>.
--   With this, you can then give an empty instance for <a>Generic</a>, and
--   the default definitions will just work. The pattern looks as follows:
--   
--   <pre>
--   import qualified <a>GHC.Generics</a> as GHC
--   import <a>Generics.SOP</a>
--   
--   ...
--   
--   data T = ... deriving (GHC.<a>Generic</a>, ...)
--   
--   instance <a>Generic</a> T -- empty
--   instance <a>HasDatatypeInfo</a> T -- empty, if you want/need metadata
--   </pre>
--   
--   <i>Option 2:</i> Derive via Template Haskell. For this, you need to
--   enable the <tt>TemplateHaskell</tt> extension. You can then use
--   <a>deriveGeneric</a> from module <a>Generics.SOP.TH</a> to have the
--   instance generated for you. The pattern looks as follows:
--   
--   <pre>
--   import <a>Generics.SOP</a>
--   import <a>Generics.SOP.TH</a>
--   
--   ...
--   
--   data T = ...
--   
--   <a>deriveGeneric</a> ''T -- derives <a>HasDatatypeInfo</a> as well
--   </pre>
--   
--   <i>Tradeoffs:</i> Whether to use Option 1 or 2 is mainly a matter of
--   personal taste. The version based on Template Haskell probably has
--   less run-time overhead.
--   
--   <i>Non-standard instances:</i> It is possible to give <a>Generic</a>
--   instances manually that deviate from the standard scheme, as long as
--   at least
--   
--   <pre>
--   <a>to</a> <a>.</a> <a>from</a> === <a>id</a> :: a -&gt; a
--   </pre>
--   
--   still holds.
class (All SListI (Code a)) => Generic (a :: *) where {
    type family Code a :: [[*]];
    type Code a = GCode a;
}

-- | Converts from a value to its structural representation.
from :: Generic a => a -> Rep a

-- | Converts from a value to its structural representation.
from :: (Generic a, GFrom a, Generic a, Rep a ~ SOP I (GCode a)) => a -> Rep a

-- | Converts from a structural representation back to the original value.
to :: Generic a => Rep a -> a

-- | Converts from a structural representation back to the original value.
to :: (Generic a, GTo a, Generic a, Rep a ~ SOP I (GCode a)) => Rep a -> a

-- | The (generic) representation of a datatype.
--   
--   A datatype is isomorphic to the sum-of-products of its code. The
--   isomorphism is witnessed by <a>from</a> and <a>to</a> from the
--   <a>Generic</a> class.
type Rep a = SOP I (Code a)

-- | Constraint that captures that a datatype is a product type, i.e., a
--   type with a single constructor.
--   
--   It also gives access to the code for the arguments of that
--   constructor.
type IsProductType (a :: *) (xs :: [*]) = (Generic a, Code a ~ '[xs])

-- | Constraint that captures that a datatype is an enumeration type, i.e.,
--   none of the constructors have any arguments.
type IsEnumType (a :: *) = (Generic a, All ((~) '[]) (Code a))

-- | Constraint that captures that a datatype is a single-constructor,
--   single-field datatype. This always holds for newtype-defined types,
--   but it can also be true for data-defined types.
--   
--   The constraint also gives access to the type that is wrapped.
type IsWrappedType (a :: *) (x :: *) = (Generic a, Code a ~ '['[x]])

-- | Constraint that captures that a datatype is a newtype. This makes use
--   of the fact that newtypes are always coercible to the type they wrap,
--   whereas datatypes are not.
type IsNewtype (a :: *) (x :: *) = (IsWrappedType a x, Coercible a x)

-- | An n-ary product.
--   
--   The product is parameterized by a type constructor <tt>f</tt> and
--   indexed by a type-level list <tt>xs</tt>. The length of the list
--   determines the number of elements in the product, and if the
--   <tt>i</tt>-th element of the list is of type <tt>x</tt>, then the
--   <tt>i</tt>-th element of the product is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble the names of the list
--   constructors.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the product
--   becomes a heterogeneous list, where the type-level list describes the
--   types of its components. For <tt><a>K</a> a</tt>, the product becomes
--   a homogeneous list, where the contents of the type-level list are
--   ignored, but its length still specifies the number of elements.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   product describes the structure of the arguments of a single data
--   constructor.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   I 'x'    :* I True  :* Nil  ::  NP I       '[ Char, Bool ]
--   K 0      :* K 1     :* Nil  ::  NP (K Int) '[ Char, Bool ]
--   Just 'x' :* Nothing :* Nil  ::  NP Maybe   '[ Char, Bool ]
--   </pre>
data NP :: (k -> *) -> [k] -> *
[Nil] :: NP f '[]
[:*] :: f x -> NP f xs -> NP f (x : xs)

-- | An n-ary sum.
--   
--   The sum is parameterized by a type constructor <tt>f</tt> and indexed
--   by a type-level list <tt>xs</tt>. The length of the list determines
--   the number of choices in the sum and if the <tt>i</tt>-th element of
--   the list is of type <tt>x</tt>, then the <tt>i</tt>-th choice of the
--   sum is of type <tt>f x</tt>.
--   
--   The constructor names are chosen to resemble Peano-style natural
--   numbers, i.e., <a>Z</a> is for "zero", and <a>S</a> is for
--   "successor". Chaining <a>S</a> and <a>Z</a> chooses the corresponding
--   component of the sum.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z         :: f x -&gt; NS f (x ': xs)
--   S . Z     :: f y -&gt; NS f (x ': y ': xs)
--   S . S . Z :: f z -&gt; NS f (x ': y ': z ': xs)
--   ...
--   </pre>
--   
--   Note that empty sums (indexed by an empty list) have no non-bottom
--   elements.
--   
--   Two common instantiations of <tt>f</tt> are the identity functor
--   <a>I</a> and the constant functor <a>K</a>. For <a>I</a>, the sum
--   becomes a direct generalization of the <a>Either</a> type to
--   arbitrarily many choices. For <tt><a>K</a> a</tt>, the result is a
--   homogeneous choice type, where the contents of the type-level list are
--   ignored, but its length specifies the number of options.
--   
--   In the context of the SOP approach to generic programming, an n-ary
--   sum describes the top-level structure of a datatype, which is a choice
--   between all of its constructors.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   Z (I 'x')      :: NS I       '[ Char, Bool ]
--   S (Z (I True)) :: NS I       '[ Char, Bool ]
--   S (Z (K 1))    :: NS (K Int) '[ Char, Bool ]
--   </pre>
data NS :: (k -> *) -> [k] -> *
[Z] :: f x -> NS f (x : xs)
[S] :: NS f xs -> NS f (x : xs)

-- | A sum of products.
--   
--   This is a 'newtype' for an <a>NS</a> of an <a>NP</a>. The elements of
--   the (inner) products are applications of the parameter <tt>f</tt>. The
--   type <a>SOP</a> is indexed by the list of lists that determines the
--   sizes of both the (outer) sum and all the (inner) products, as well as
--   the types of all the elements of the inner products.
--   
--   An <tt><a>SOP</a> <a>I</a></tt> reflects the structure of a normal
--   Haskell datatype. The sum structure represents the choice between the
--   different constructors, the product structure represents the arguments
--   of each constructor.
newtype SOP (f :: (k -> *)) (xss :: [[k]])
SOP :: (NS (NP f) xss) -> SOP

-- | Unwrap a sum of products.
unSOP :: SOP f xss -> NS (NP f) xss

-- | A product of products.
--   
--   This is a 'newtype' for an <a>NP</a> of an <a>NP</a>. The elements of
--   the inner products are applications of the parameter <tt>f</tt>. The
--   type <a>POP</a> is indexed by the list of lists that determines the
--   lengths of both the outer and all the inner products, as well as the
--   types of all the elements of the inner products.
--   
--   A <a>POP</a> is reminiscent of a two-dimensional table (but the inner
--   lists can all be of different length). In the context of the SOP
--   approach to generic programming, a <a>POP</a> is useful to represent
--   information that is available for all arguments of all constructors of
--   a datatype.
newtype POP (f :: (k -> *)) (xss :: [[k]])
POP :: (NP (NP f) xss) -> POP

-- | Unwrap a product of products.
unPOP :: POP f xss -> NP (NP f) xss

-- | Metadata for a datatype.
--   
--   A value of type <tt><a>DatatypeInfo</a> c</tt> contains the
--   information about a datatype that is not contained in
--   <tt><tt>Code</tt> c</tt>. This information consists primarily of the
--   names of the datatype, its constructors, and possibly its record
--   selectors.
--   
--   The constructor indicates whether the datatype has been declared using
--   <tt>newtype</tt> or not.
data DatatypeInfo :: [[*]] -> *
[ADT] :: ModuleName -> DatatypeName -> NP ConstructorInfo xss -> DatatypeInfo xss
[Newtype] :: ModuleName -> DatatypeName -> ConstructorInfo '[x] -> DatatypeInfo '['[x]]

-- | The module name where a datatype is defined.
moduleName :: DatatypeInfo xss -> ModuleName

-- | The name of a datatype (or newtype).
datatypeName :: DatatypeInfo xss -> DatatypeName

-- | The constructor info for a datatype (or newtype).
constructorInfo :: DatatypeInfo xss -> NP ConstructorInfo xss

-- | Metadata for a single constructors.
--   
--   This is indexed by the product structure of the constructor
--   components.
data ConstructorInfo :: [*] -> *
[Constructor] :: SListI xs => ConstructorName -> ConstructorInfo xs
[Infix] :: ConstructorName -> Associativity -> Fixity -> ConstructorInfo '[x, y]
[Record] :: SListI xs => ConstructorName -> NP FieldInfo xs -> ConstructorInfo xs

-- | The name of a constructor.
constructorName :: ConstructorInfo xs -> ConstructorName

-- | For records, this functor maps the component to its selector name.
data FieldInfo :: * -> *
[FieldInfo] :: FieldName -> FieldInfo a

-- | The name of a field.
fieldName :: FieldInfo a -> FieldName

-- | A class of datatypes that have associated metadata.
--   
--   It is possible to use the sum-of-products approach to generic
--   programming without metadata. If you need metadata in a function, an
--   additional constraint on this class is in order.
--   
--   You typically don't define instances of this class by hand, but rather
--   derive the class instance automatically. See the documentation of
--   <a>Generic</a> for the options.
class HasDatatypeInfo a where {
    type family DatatypeInfoOf a :: DatatypeInfo;
    type DatatypeInfoOf a = GDatatypeInfoOf a;
}

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: HasDatatypeInfo a => proxy a -> DatatypeInfo (Code a)

-- | Term-level datatype info; by default, the term-level datatype info is
--   produced from the type-level info.
datatypeInfo :: (HasDatatypeInfo a, GDatatypeInfo a, GCode a ~ Code a) => proxy a -> DatatypeInfo (Code a)

-- | The name of a datatype.
type DatatypeName = String

-- | The name of a module.
type ModuleName = String

-- | The name of a data constructor.
type ConstructorName = String

-- | The name of a field / record selector.
type FieldName = String

-- | Datatype to represent the associativity of a constructor
data Associativity :: *
LeftAssociative :: Associativity
RightAssociative :: Associativity
NotAssociative :: Associativity

-- | The fixity of an infix constructor.
type Fixity = Int

-- | A generalization of <a>pure</a> or <a>return</a> to higher kinds.
class HPure (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>pure</a> directly.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hpure</a>, <a>pure_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a) -&gt; <a>NP</a>  f xs
--   <a>hpure</a>, <a>pure_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a) -&gt; <a>POP</a> f xss
--   </pre>
hpure :: (HPure h, SListIN h xs) => (forall a. f a) -> h f xs

-- | A variant of <a>hpure</a> that allows passing in a constrained
--   argument.
--   
--   Calling <tt><a>hcpure</a> f s</tt> where <tt>s :: h f xs</tt> causes
--   <tt>f</tt> to be applied at all the types that are contained in
--   <tt>xs</tt>. Therefore, the constraint <tt>c</tt> has to be satisfied
--   for all elements of <tt>xs</tt>, which is what <tt><tt>AllMap</tt> h c
--   xs</tt> states.
--   
--   Morally, <a>hpure</a> is a special case of <a>hcpure</a> where the
--   constraint is empty. However, it is in the nature of how
--   <tt>AllMap</tt> is defined as well as current GHC limitations that it
--   is tricky to prove to GHC in general that <tt><tt>AllMap</tt> h c
--   NoConstraint xs</tt> is always satisfied. Therefore, we typically
--   define <a>hpure</a> separately and directly, and make it a member of
--   the class.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcpure</a>, <a>cpure_NP</a>  :: (<a>All</a>  c xs ) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>NP</a>  f xs
--   <a>hcpure</a>, <a>cpure_POP</a> :: (<a>All2</a> c xss) =&gt; proxy c -&gt; (forall a. c a =&gt; f a) -&gt; <a>POP</a> f xss
--   </pre>
hcpure :: (HPure h, (AllN h c xs)) => proxy c -> (forall a. c a => f a) -> h f xs

-- | Obtain the head of an n-ary product.
hd :: NP f (x : xs) -> f x

-- | Obtain the tail of an n-ary product.
tl :: NP f (x : xs) -> NP f xs

-- | The type of projections from an n-ary product.
type Projection (f :: k -> *) (xs :: [k]) = K (NP f xs) -.-> f

-- | Compute all projections from an n-ary product.
--   
--   Each element of the resulting product contains one of the projections.
projections :: forall xs f. SListI xs => NP (Projection f xs) xs
shiftProjection :: Projection f xs a -> Projection f (x : xs) a

-- | Lifted functions.
newtype f (-.->) g a
Fn :: (f a -> g a) -> (-.->) f g a
[apFn] :: (-.->) f g a -> f a -> g a

-- | Construct a lifted function.
--   
--   Same as <a>Fn</a>. Only available for uniformity with the higher-arity
--   versions.
fn :: (f a -> f' a) -> (f -.-> f') a

-- | Construct a binary lifted function.
fn_2 :: (f a -> f' a -> f'' a) -> (f -.-> (f' -.-> f'')) a

-- | Construct a ternary lifted function.
fn_3 :: (f a -> f' a -> f'' a -> f''' a) -> (f -.-> (f' -.-> (f'' -.-> f'''))) a

-- | Construct a quarternary lifted function.
fn_4 :: (f a -> f' a -> f'' a -> f''' a -> f'''' a) -> (f -.-> (f' -.-> (f'' -.-> (f''' -.-> f'''')))) a

-- | Maps a structure containing sums to the corresponding product
--   structure.

-- | A generalization of <a>&lt;*&gt;</a>.
class (Prod (Prod h) ~ Prod h, HPure (Prod h)) => HAp (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>&lt;*&gt;</a>.
--   
--   For products (<a>NP</a>) as well as products of products (<a>POP</a>),
--   the correspondence is rather direct. We combine a structure containing
--   (lifted) functions and a compatible structure containing corresponding
--   arguments into a compatible structure containing results.
--   
--   The same combinator can also be used to combine a product structure of
--   functions with a sum structure of arguments, which then results in
--   another sum structure of results. The sum structure determines which
--   part of the product structure will be used.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hap</a>, <a>ap_NP</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  g xs
--   <a>hap</a>, <a>ap_NS</a>  :: <a>NP</a>  (f -.-&gt; g) xs  -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  g xs
--   <a>hap</a>, <a>ap_POP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>POP</a> f xss -&gt; <a>POP</a> g xss
--   <a>hap</a>, <a>ap_SOP</a> :: <a>POP</a> (f -.-&gt; g) xss -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> g xss
--   </pre>
hap :: HAp h => Prod h (f -.-> g) xs -> h f xs -> h g xs

-- | A generalized form of <a>liftA</a>, which in turn is a generalized
--   <a>map</a>.
--   
--   Takes a lifted function and applies it to every element of a structure
--   while preserving its shape.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA</a> f xs = <a>hpure</a> (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA</a>, <a>liftA_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs
--   <a>hliftA</a>, <a>liftA_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a) -&gt; <a>NS</a>  f xs  -&gt; <a>NS</a>  f' xs
--   <a>hliftA</a>, <a>liftA_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss
--   <a>hliftA</a>, <a>liftA_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a) -&gt; <a>SOP</a> f xss -&gt; <a>SOP</a> f' xss
--   </pre>
hliftA :: (SListIN (Prod h) xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | A generalized form of <a>liftA2</a>, which in turn is a generalized
--   <a>zipWith</a>.
--   
--   Takes a lifted binary function and uses it to combine two structures
--   of equal shape into a single structure.
--   
--   It either takes two product structures to a product structure, or one
--   product and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA2</a> f xs ys = <a>hpure</a> (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA2</a>, <a>liftA2_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NS</a>  f' xs  -&gt; <a>NS</a>  f'' xs
--   <a>hliftA2</a>, <a>liftA2_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss
--   <a>hliftA2</a>, <a>liftA2_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a) -&gt; <a>POP</a> f xss -&gt; <a>SOP</a> f' xss -&gt; <a>SOP</a> f'' xss
--   </pre>
hliftA2 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | A generalized form of <a>liftA3</a>, which in turn is a generalized
--   <a>zipWith3</a>.
--   
--   Takes a lifted ternary function and uses it to combine three
--   structures of equal shape into a single structure.
--   
--   It either takes three product structures to a product structure, or
--   two product structures and one sum structure to a sum structure.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hliftA3</a> f xs ys zs = <a>hpure</a> (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hliftA3</a>, <a>liftA3_NP</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NP</a>  f'' xs  -&gt; <a>NP</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_NS</a>  :: <a>SListI</a>  xs  =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>NP</a>  f xs  -&gt; <a>NP</a>  f' xs  -&gt; <a>NS</a>  f'' xs  -&gt; <a>NS</a>  f''' xs
--   <a>hliftA3</a>, <a>liftA3_POP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>POP</a> f'' xss -&gt; <a>POP</a> f''' xs
--   <a>hliftA3</a>, <a>liftA3_SOP</a> :: <a>SListI2</a> xss =&gt; (forall a. f a -&gt; f' a -&gt; f'' a -&gt; f''' a) -&gt; <a>POP</a> f xss -&gt; <a>POP</a> f' xss -&gt; <a>SOP</a> f'' xss -&gt; <a>SOP</a> f''' xs
--   </pre>
hliftA3 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Variant of <a>hliftA</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA</a> p f xs = <a>hcpure</a> p (<a>fn</a> f) ` <a>hap</a> ` xs
--   </pre>
hcliftA :: (AllN (Prod h) c xs, HAp h) => proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Variant of <a>hcliftA2</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA2</a> p f xs ys = <a>hcpure</a> p (<a>fn_2</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys
--   </pre>
hcliftA2 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Variant of <a>hcliftA3</a> that takes a constrained function.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA3</a> p f xs ys zs = <a>hcpure</a> p (<a>fn_3</a> f) ` <a>hap</a> ` xs ` <a>hap</a> ` ys ` <a>hap</a> ` zs
--   </pre>
hcliftA3 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hliftA</a>.
hmap :: (SListIN (Prod h) xs, HAp h) => (forall a. f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hliftA2</a>.
hzipWith :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hliftA3</a>.
hzipWith3 :: (SListIN (Prod h) xs, HAp h, HAp (Prod h)) => (forall a. f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | Another name for <a>hcliftA</a>.
hcmap :: (AllN (Prod h) c xs, HAp h) => proxy c -> (forall a. c a => f a -> f' a) -> h f xs -> h f' xs

-- | Another name for <a>hcliftA2</a>.
hczipWith :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a) -> Prod h f xs -> h f' xs -> h f'' xs

-- | Another name for <a>hcliftA3</a>.
hczipWith3 :: (AllN (Prod h) c xs, HAp h, HAp (Prod h)) => proxy c -> (forall a. c a => f a -> f' a -> f'' a -> f''' a) -> Prod h f xs -> Prod h f' xs -> h f'' xs -> h f''' xs

-- | The type of injections into an n-ary sum.
--   
--   If you expand the type synonyms and newtypes involved, you get
--   
--   <pre>
--   Injection f xs a = (f -.-&gt; K (NS f xs)) a ~= f a -&gt; K (NS f xs) a ~= f a -&gt; NS f xs
--   </pre>
--   
--   If we pick <tt>a</tt> to be an element of <tt>xs</tt>, this indeed
--   corresponds to an injection into the sum.
type Injection (f :: k -> *) (xs :: [k]) = f -.-> K (NS f xs)

-- | Compute all injections into an n-ary sum.
--   
--   Each element of the resulting product contains one of the injections.
injections :: forall xs f. SListI xs => NP (Injection f xs) xs

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.

-- | <i>Deprecated: Use <a>shiftInjection</a> instead.</i>
shift :: Injection f xs a -> Injection f (x : xs) a

-- | Shift an injection.
--   
--   Given an injection, return an injection into a sum that is one
--   component larger.
shiftInjection :: Injection f xs a -> Injection f (x : xs) a

-- | Maps a structure containing products to the corresponding sum
--   structure.

-- | A class for applying all injections corresponding to a sum-like
--   structure to a table containing suitable arguments.
class (UnProd (Prod h) ~ h) => HApInjs (h :: (k -> *) -> (l -> *))

-- | For a given table (product-like structure), produce a list where each
--   element corresponds to the application of an injection function into
--   the corresponding sum-like structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hapInjs</a>, <a>apInjs_NP</a>  :: <a>SListI</a>  xs  =&gt; <a>NP</a>  f xs -&gt; [<a>NS</a>  f xs ]
--   <a>hapInjs</a>, <a>apInjs_SOP</a> :: <a>SListI2</a> xss =&gt; <a>POP</a> f xs -&gt; [<a>SOP</a> f xss]
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (I 'x' :* I True :* I 2 :* Nil) :: [NS I '[Char, Bool, Int]]
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hapInjs (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil)) :: [SOP I '[ '[Char], '[Bool, Int]]]
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
--   
--   Unfortunately the type-signatures are required in GHC-7.10 and older.
hapInjs :: (HApInjs h, (SListIN h xs)) => Prod h f xs -> [h f xs]

-- | Apply injections to a product.
--   
--   Given a product containing all possible choices, produce a list of
--   sums by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_NP (I 'x' :* I True :* I 2 :* Nil)
--   [Z (I 'x'),S (Z (I True)),S (S (Z (I 2)))]
--   </pre>
apInjs_NP :: SListI xs => NP f xs -> [NS f xs]

-- | Apply injections to a product of product.
--   
--   This operates on the outer product only. Given a product containing
--   all possible choices (that are products), produce a list of sums (of
--   products) by applying each injection to the appropriate element.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; apInjs_POP (POP ((I 'x' :* Nil) :* (I True :* I 2 :* Nil) :* Nil))
--   [SOP (Z (I 'x' :* Nil)),SOP (S (Z (I True :* I 2 :* Nil)))]
--   </pre>
apInjs_POP :: SListI xss => POP f xss -> [SOP f xss]

-- | Extract the payload from a unary sum.
--   
--   For larger sums, this function would be partial, so it is only
--   provided with a rather restrictive type.
--   
--   <i>Example:</i>
--   
--   <pre>
--   &gt;&gt;&gt; unZ (Z (I 'x'))
--   I 'x'
--   </pre>
unZ :: NS f '[x] -> f x

-- | A class for determining which choice in a sum-like structure a value
--   represents.
class HIndex (h :: (k -> *) -> (l -> *))

-- | If <tt>h</tt> is a sum-like structure representing a choice between
--   <tt>n</tt> different options, and <tt>x</tt> is a value of type <tt>h
--   f xs</tt>, then <tt><a>hindex</a> x</tt> returns a number between
--   <tt>0</tt> and <tt>n - 1</tt> representing the index of the choice
--   made by <tt>x</tt>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hindex</a>, <a>index_NS</a>  :: <a>NS</a>  f xs -&gt; Int
--   <a>hindex</a>, <a>index_SOP</a> :: <a>SOP</a> f xs -&gt; Int
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hindex (S (S (Z (I False))))
--   2
--   
--   &gt;&gt;&gt; hindex (Z (K ()))
--   0
--   
--   &gt;&gt;&gt; hindex (SOP (S (Z (I True :* I 'x' :* Nil))))
--   1
--   </pre>
hindex :: HIndex h => h f xs -> Int

-- | Lift a constrained function operating on a list-indexed structure to a
--   function on a list-of-list-indexed structure.
--   
--   This is a variant of <a>hcliftA</a>.
--   
--   <i>Specification:</i>
--   
--   <pre>
--   <a>hcliftA'</a> p f xs = <a>hpure</a> (<a>fn_2</a> $ \ <tt>AllDictC</tt> -&gt; f) ` <a>hap</a> ` <tt>allDict_NP</tt> p ` <a>hap</a> ` xs
--   </pre>
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NP</a> f xss -&gt; <a>NP</a> f' xss
--   <a>hcliftA'</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall xs. <a>All</a> c xs =&gt; f xs -&gt; f' xs) -&gt; <a>NS</a> f xss -&gt; <a>NS</a> f' xss
--   </pre>

-- | <i>Deprecated: Use <a>hcliftA</a> or <a>hcmap</a> instead.</i>
hcliftA' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs) -> h f xss -> h f' xss

-- | Like <a>hcliftA'</a>, but for binary functions.

-- | <i>Deprecated: Use <a>hcliftA2</a> or <a>hczipWith</a> instead.</i>
hcliftA2' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs -> f'' xs) -> Prod h f xss -> h f' xss -> h f'' xss

-- | Like <a>hcliftA'</a>, but for ternay functions.

-- | <i>Deprecated: Use <a>hcliftA3</a> or <a>hczipWith3</a> instead.</i>
hcliftA3' :: (All2 c xss, Prod h ~ NP, HAp h) => proxy c -> (forall xs. All c xs => f xs -> f' xs -> f'' xs -> f''' xs) -> Prod h f xss -> Prod h f' xss -> h f'' xss -> h f''' xss

-- | Compare two sums with respect to the choice they are making.
--   
--   A value that chooses the first option is considered smaller than one
--   that chooses the second option.
--   
--   If the choices are different, then either the first (if the first is
--   smaller than the second) or the third (if the first is larger than the
--   second) argument are called. If both choices are equal, then the
--   second argument is called, which has access to the elements contained
--   in the sums.
compare_NS :: forall r f g xs. r -> (forall x. f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Constrained version of <a>compare_NS</a>.
ccompare_NS :: forall c proxy r f g xs. (All c xs) => proxy c -> r -> (forall x. c x => f x -> g x -> r) -> r -> NS f xs -> NS g xs -> r

-- | Compare two sums of products with respect to the choice in the sum
--   they are making.
--   
--   Only the sum structure is used for comparison. This is a small wrapper
--   around <a>ccompare_NS</a> for a common special case.
compare_SOP :: forall r f g xss. r -> (forall xs. NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Constrained version of <a>compare_SOP</a>.
ccompare_SOP :: forall c proxy r f g xss. (All2 c xss) => proxy c -> r -> (forall xs. All c xs => NP f xs -> NP g xs -> r) -> r -> SOP f xss -> SOP g xss -> r

-- | Maps products to lists, and sums to identities.

-- | A class for collapsing a heterogeneous structure into a homogeneous
--   one.
class HCollapse (h :: (k -> *) -> (l -> *))

-- | Collapse a heterogeneous structure with homogeneous elements into a
--   homogeneous structure.
--   
--   If a heterogeneous structure is instantiated to the constant functor
--   <a>K</a>, then it is in fact homogeneous. This function maps such a
--   value to a simpler Haskell datatype reflecting that. An
--   <tt><tt>NS</tt> (<a>K</a> a)</tt> contains a single <tt>a</tt>, and an
--   <tt><tt>NP</tt> (<a>K</a> a)</tt> contains a list of <tt>a</tt>s.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcollapse</a>, <a>collapse_NP</a>  :: <a>NP</a>  (<a>K</a> a) xs  -&gt;  [a]
--   <a>hcollapse</a>, <a>collapse_NS</a>  :: <a>NS</a>  (<a>K</a> a) xs  -&gt;   a
--   <a>hcollapse</a>, <a>collapse_POP</a> :: <a>POP</a> (<a>K</a> a) xss -&gt; [[a]]
--   <a>hcollapse</a>, <a>collapse_SOP</a> :: <a>SOP</a> (<a>K</a> a) xss -&gt;  [a]
--   </pre>
hcollapse :: (HCollapse h, SListIN h xs) => h (K a) xs -> CollapseTo h a

-- | A generalization of <a>traverse_</a> or <a>foldMap</a>.
class HTraverse_ (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>traverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse_</a>, <a>ctraverse__NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <a>hctraverse_</a>, <a>ctraverse__SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
hctraverse_ :: (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g ()) -> h f xs -> g ()

-- | Unconstrained version of <a>hctraverse_</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <tt>traverse_</tt>, <a>traverse__NP</a>  :: (<tt>SListI</tt>  xs , 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NP</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__NS</a>  :: (<tt>SListI</tt>  xs , 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>NS</a>  f xs  -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__POP</a> :: (<a>SListI2</a> xss, 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>POP</a> f xss -&gt; g ()
--   <tt>traverse_</tt>, <a>traverse__SOP</a> :: (<a>SListI2</a> xss, 'Applicative g') =&gt; (forall a. f a -&gt; g ()) -&gt; <a>SOP</a> f xss -&gt; g ()
--   </pre>
htraverse_ :: (HTraverse_ h, SListIN h xs, Applicative g) => (forall a. f a -> g ()) -> h f xs -> g ()

-- | Special case of <a>hctraverse_</a>.
hcfoldMap :: (HTraverse_ h, AllN h c xs, Monoid m) => proxy c -> (forall a. c a => f a -> m) -> h f xs -> m

-- | Flipped version of <a>hctraverse_</a>.
hcfor_ :: (HTraverse_ h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall a. c a => f a -> g ()) -> g ()

-- | A generalization of <a>sequenceA</a>.
class HAp h => HSequence (h :: (k -> *) -> (l -> *))

-- | Corresponds to <a>sequenceA</a>.
--   
--   Lifts an applicative functor out of a structure.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hsequence'</a>, <a>sequence'_NP</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NP</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NP</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_NS</a>  :: (<a>SListI</a>  xs , <a>Applicative</a> f) =&gt; <a>NS</a>  (f <a>:.:</a> g) xs  -&gt; f (<a>NS</a>  g xs )
--   <a>hsequence'</a>, <a>sequence'_POP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>POP</a> (f <a>:.:</a> g) xss -&gt; f (<a>POP</a> g xss)
--   <a>hsequence'</a>, <a>sequence'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> f) =&gt; <a>SOP</a> (f <a>:.:</a> g) xss -&gt; f (<a>SOP</a> g xss)
--   </pre>
hsequence' :: (HSequence h, SListIN h xs, Applicative f) => h (f :.: g) xs -> f (h g xs)

-- | Corresponds to <a>traverse</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hctraverse'</a>, <a>ctraverse'_NP</a>  :: (<a>All</a>  c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_NS</a>  :: (<a>All2</a> c xs , <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>hctraverse'</a>, <a>ctraverse'_POP</a> :: (<a>All</a>  c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>hctraverse'</a>, <a>ctraverse'_SOP</a> :: (<a>All2</a> c xss, <a>Applicative</a> g) =&gt; proxy c -&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
hctraverse' :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Unconstrained variant of <a>htraverse'</a>.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>htraverse'</a>, <a>traverse'_NP</a>  :: (<tt>SListI</tt>  xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NP</a>  f xs  -&gt; g (<a>NP</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_NS</a>  :: (<a>SListI2</a> xs , <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>NS</a>  f xs  -&gt; g (<a>NS</a>  f' xs )
--   <a>htraverse'</a>, <a>traverse'_POP</a> :: (<tt>SListI</tt>  xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>POP</a> f xss -&gt; g (<a>POP</a> f' xss)
--   <a>htraverse'</a>, <a>traverse'_SOP</a> :: (<a>SListI2</a> xss, <a>Applicative</a> g) =&gt; (forall a. c a =&gt; f a -&gt; g (f' a)) -&gt; <a>SOP</a> f xss -&gt; g (<a>SOP</a> f' xss)
--   </pre>
htraverse' :: (HSequence h, SListIN h xs, Applicative g) => (forall a. f a -> g (f' a)) -> h f xs -> g (h f' xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>I</a></tt>.
hsequence :: (SListIN h xs, SListIN (Prod h) xs, HSequence h) => Applicative f => h f xs -> f (h I xs)

-- | Special case of <a>hsequence'</a> where <tt>g = <a>K</a> a</tt>.
hsequenceK :: (SListIN h xs, SListIN (Prod h) xs, Applicative f, HSequence h) => h (K (f a)) xs -> f (h (K a) xs)

-- | Special case of <a>hctraverse'</a> where <tt>f' = <a>I</a></tt>.
hctraverse :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> (forall a. c a => f a -> g a) -> h f xs -> g (h I xs)

-- | Flipped version of <a>hctraverse</a>.
hcfor :: (HSequence h, AllN h c xs, Applicative g) => proxy c -> h f xs -> (forall a. c a => f a -> g a) -> g (h I xs)

-- | A class for expanding sum structures into corresponding product
--   structures, filling in the slots not targeted by the sum with default
--   values.
class HExpand (h :: (k -> *) -> (l -> *))

-- | Expand a given sum structure into a corresponding product structure by
--   placing the value contained in the sum into the corresponding position
--   in the product, and using the given default value for all other
--   positions.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hexpand</a>, <a>expand_NS</a>  :: <a>SListI</a> xs  =&gt; (forall x . f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hexpand</a>, <a>expand_SOP</a> :: <a>SListI2</a> xss =&gt; (forall x . f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hexpand Nothing (S (Z (Just 3))) :: NP Maybe '[Char, Int, Bool]
--   Nothing :* Just 3 :* Nothing :* Nil
--   
--   &gt;&gt;&gt; hexpand [] (SOP (S (Z ([1,2] :* "xyz" :* Nil)))) :: POP [] '[ '[Bool], '[Int, Char] ]
--   POP (([] :* Nil) :* ([1,2] :* "xyz" :* Nil) :* Nil)
--   </pre>
hexpand :: (HExpand h, (SListIN (Prod h) xs)) => (forall x. f x) -> h f xs -> Prod h f xs

-- | Variant of <a>hexpand</a> that allows passing a constrained default.
--   
--   <i>Instances:</i>
--   
--   <pre>
--   <a>hcexpand</a>, <a>cexpand_NS</a>  :: <a>All</a>  c xs  =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>NS</a>  f xs  -&gt; <a>NP</a>  f xs
--   <a>hcexpand</a>, <a>cexpand_SOP</a> :: <a>All2</a> c xss =&gt; proxy c -&gt; (forall x . c x =&gt; f x) -&gt; <a>SOP</a> f xss -&gt; <a>POP</a> f xss
--   </pre>
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Bounded) (I minBound) (S (Z (I 20))) :: NP I '[Bool, Int, Ordering]
--   I False :* I 20 :* I LT :* Nil
--   
--   &gt;&gt;&gt; hcexpand (Proxy :: Proxy Num) (I 0) (SOP (S (Z (I 1 :* I 2 :* Nil)))) :: POP I '[ '[Double], '[Int, Int] ]
--   POP ((I 0.0 :* Nil) :* (I 1 :* I 2 :* Nil) :* Nil)
--   </pre>
hcexpand :: (HExpand h, (AllN (Prod h) c xs)) => proxy c -> (forall x. c x => f x) -> h f xs -> Prod h f xs

-- | A class for transforming structures into related structures with a
--   different index list, as long as the index lists have the same shape
--   and the elements and interpretation functions are suitably related.
class (Same h1 ~ h2, Same h2 ~ h1) => HTrans (h1 :: (k1 -> *) -> (l1 -> *)) (h2 :: (k2 -> *) -> (l2 -> *))

-- | Transform a structure into a related structure given a conversion
--   function for the elements.
htrans :: (HTrans h1 h2, AllZipN (Prod h1) c xs ys) => proxy c -> (forall x y. c x y => f x -> g y) -> h1 f xs -> h2 g ys

-- | Coerce a structure into a representationally equal structure.
--   
--   <i>Examples:</i>
--   
--   <pre>
--   &gt;&gt;&gt; hcoerce (I (Just LT) :* I (Just 'x') :* I (Just True) :* Nil) :: NP Maybe '[Ordering, Char, Bool]
--   Just LT :* Just 'x' :* Just True :* Nil
--   
--   &gt;&gt;&gt; hcoerce (SOP (Z (K True :* K False :* Nil))) :: SOP I '[ '[Bool, Bool], '[Bool] ]
--   SOP (Z (I True :* I False :* Nil))
--   </pre>
hcoerce :: (HTrans h1 h2, AllZipN (Prod h1) (LiftedCoercible f g) xs ys, HTrans h1 h2) => h1 f xs -> h2 g ys

-- | Specialization of <a>hcoerce</a>.
hfromI :: (AllZipN (Prod h1) (LiftedCoercible I f) xs ys, HTrans h1 h2) => h1 I xs -> h2 f ys

-- | Specialization of <a>hcoerce</a>.
htoI :: (AllZipN (Prod h1) (LiftedCoercible f I) xs ys, HTrans h1 h2) => h1 f xs -> h2 I ys

-- | Construct a homogeneous n-ary product from a normal Haskell list.
--   
--   Returns <a>Nothing</a> if the length of the list does not exactly
--   match the expected size of the product.
fromList :: SListI xs => [a] -> Maybe (NP (K a) xs)

-- | The constant type functor.
--   
--   Like <a>Constant</a>, but kind-polymorphic in its second argument and
--   with a shorter name.
newtype K (a :: *) (b :: k)
K :: a -> K

-- | Extract the contents of a <a>K</a> value.
unK :: K a b -> a

-- | The identity type functor.
--   
--   Like <a>Identity</a>, but with a shorter name.
newtype I (a :: *)
I :: a -> I

-- | Extract the contents of an <a>I</a> value.
unI :: I a -> a

-- | Composition of functors.
--   
--   Like <a>Compose</a>, but kind-polymorphic and with a shorter name.
newtype (:.:) (f :: l -> *) (g :: k -> l) (p :: k)
Comp :: (f (g p)) -> (:.:)

-- | Extract the contents of a <a>Comp</a> value.
unComp :: (f :.: g) p -> f (g p)

-- | Lift the given function.
mapII :: (a -> b) -> I a -> I b

-- | Lift the given function.
mapIK :: (a -> b) -> I a -> K b c

-- | Lift the given function.
mapKI :: (a -> b) -> K a c -> I b

-- | Lift the given function.
mapKK :: (a -> b) -> K a c -> K b d

-- | Lift the given function.
mapIII :: (a -> b -> c) -> I a -> I b -> I c

-- | Lift the given function.
mapIIK :: (a -> b -> c) -> I a -> I b -> K c d

-- | Lift the given function.
mapIKI :: (a -> b -> c) -> I a -> K b d -> I c

-- | Lift the given function.
mapIKK :: (a -> b -> c) -> I a -> K b d -> K c e

-- | Lift the given function.
mapKII :: (a -> b -> c) -> K a d -> I b -> I c

-- | Lift the given function.
mapKIK :: (a -> b -> c) -> K a d -> I b -> K c e

-- | Lift the given function.
mapKKI :: (a -> b -> c) -> K a d -> K b e -> I c

-- | Lift the given function.
mapKKK :: (a -> b -> c) -> K a d -> K b e -> K c f

-- | Require a constraint for every element of a list.
--   
--   If you have a datatype that is indexed over a type-level list, then
--   you can use <a>All</a> to indicate that all elements of that
--   type-level list must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All Eq '[ Int, Bool, Char ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All Eq xs =&gt; NP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the n-ary
--   product satisfy <a>Eq</a>.
class (AllF f xs, SListI xs) => All (f :: k -> Constraint) (xs :: [k])

-- | Require a constraint for every element of a list of lists.
--   
--   If you have a datatype that is indexed over a type-level list of
--   lists, then you can use <a>All2</a> to indicate that all elements of
--   the innert lists must satisfy a given constraint.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All2 Eq '[ '[ Int ], '[ Bool, Char ] ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Eq Int, Eq Bool, Eq Char)
--   </pre>
--   
--   <i>Example:</i> A type signature such as
--   
--   <pre>
--   f :: All2 Eq xss =&gt; SOP I xs -&gt; ...
--   </pre>
--   
--   means that <tt>f</tt> can assume that all elements of the sum of
--   product satisfy <a>Eq</a>.
class (AllF (All f) xss, SListI xss) => All2 f xss

-- | Require a constraint for pointwise for every pair of elements from two
--   lists.
--   
--   <i>Example:</i> The constraint
--   
--   <pre>
--   All (~) '[ Int, Bool, Char ] '[ a, b, c ]
--   </pre>
--   
--   is equivalent to the constraint
--   
--   <pre>
--   (Int ~ a, Bool ~ b, Char ~ c)
--   </pre>
class (SListI xs, SListI ys, SameShapeAs xs ys, SameShapeAs ys xs, AllZipF c xs ys) => AllZip (c :: a -> b -> Constraint) (xs :: [a]) (ys :: [b])

-- | Require a constraint for pointwise for every pair of elements from two
--   lists of lists.
class (AllZipF (AllZip f) xss yss, SListI xss, SListI yss, SameShapeAs xss yss, SameShapeAs yss xss) => AllZip2 f xss yss

-- | A generalization of <a>All</a> and <a>All2</a>.
--   
--   The family <a>AllN</a> expands to <a>All</a> or <a>All2</a> depending
--   on whether the argument is indexed by a list or a list of lists.

-- | A generalization of <a>AllZip</a> and <a>AllZip2</a>.
--   
--   The family <a>AllZipN</a> expands to <a>AllZip</a> or <a>AllZip2</a>
--   depending on whther the argument is indexed by a list or a list of
--   lists.

-- | Composition of constraints.
--   
--   Note that the result of the composition must be a constraint, and
--   therefore, in <tt>f <tt>:.</tt> g</tt>, the kind of <tt>f</tt> is
--   <tt>k -&gt; <a>Constraint</a></tt>. The kind of <tt>g</tt>, however,
--   is <tt>l -&gt; k</tt> and can thus be an normal type constructor.
--   
--   A typical use case is in connection with <a>All</a> on an <tt>NP</tt>
--   or an <tt>NS</tt>. For example, in order to denote that all elements
--   on an <tt><tt>NP</tt> f xs</tt> satisfy <a>Show</a>, we can say
--   <tt><a>All</a> (<a>Show</a> :. f) xs</tt>.
class (f (g x)) => f `Compose` g x

-- | Pairing of constraints.
class (f x, g x) => f `And` g x

-- | A constraint that can always be satisfied.
class Top x

-- | The constraint <tt>LiftedCoercible f g x y</tt> is equivalent to
--   <tt>Coercible (f x) (g y)</tt>.
class Coercible (f x) (g y) => LiftedCoercible f g x y

-- | Type family that forces a type-level list to be of the same shape as
--   the given type-level list.
--   
--   The main use of this constraint is to help type inference to learn
--   something about otherwise unknown type-level lists.

-- | Explicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over. For every
--   type-level list <tt>xs</tt>, there is one non-bottom value of type
--   <tt><a>SList</a> xs</tt>.
--   
--   Note that these singleton lists are polymorphic in the list elements;
--   we do not require a singleton representation for them.
data SList :: [k] -> *
[SNil] :: SList '[]
[SCons] :: SListI xs => SList (x : xs)

-- | Implicit singleton list.
--   
--   A singleton list can be used to reveal the structure of a type-level
--   list argument that the function is quantified over.
--   
--   The class <a>SListI</a> should have instances that match the
--   constructors of <a>SList</a>.
class SListI (xs :: [k])

-- | Get hold of the explicit singleton (that one can then pattern match
--   on).
sList :: SListI xs => SList xs

-- | Require a singleton for every inner list in a list of lists.
type SListI2 = All SListI

-- | Explicit singleton type.
--   
--   Just provided for limited backward compatibility.

-- | <i>Deprecated: Use <a>SList</a> instead.</i>
type Sing = SList

-- | General class for implicit singletons.
--   
--   Just provided for limited backward compatibility.

-- | <i>Deprecated: Use <a>SListI</a> instead.</i>
class SListI xs => SingI (xs :: [k])

-- | <i>Deprecated: Use <a>sList</a> instead.</i>
sing :: SingI xs => Sing xs

-- | Occassionally it is useful to have an explicit, term-level,
--   representation of type-level lists (esp because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9108)</a>
data Shape :: [k] -> *
[ShapeNil] :: Shape '[]
[ShapeCons] :: SListI xs => Shape xs -> Shape (x : xs)

-- | The shape of a type-level list.
shape :: forall (xs :: [k]). SListI xs => Shape xs

-- | The length of a type-level list.
lengthSList :: forall (xs :: [k]) proxy. SListI xs => proxy xs -> Int

-- | Old name for <a>lengthSList</a>.

-- | <i>Deprecated: Use <a>lengthSList</a> instead.</i>
lengthSing :: SListI xs => proxy xs -> Int

-- | A concrete, poly-kinded proxy type
data Proxy k (t :: k) :: forall k. () => k -> *
Proxy :: Proxy k
